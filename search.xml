<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于有限体积法和交错网格的SIMPLE算法推导及实现</title>
      <link href="/2024/05/02/post05/"/>
      <url>/2024/05/02/post05/</url>
      
        <content type="html"><![CDATA[<h1 id="基于有限体积法和交错网格的simple算法推导及实现">基于有限体积法和交错网格的SIMPLE算法推导及实现</h1><p>SIMPLE算法，半隐式速度压力耦合算法，是专门求解不可压流体流动的算法。由于不可压流体控制方程中，密度常常被视为常数，没有表征流体密度、压力、温度联系的状态方程，压力以梯度项的形式存在于动量方程中，无法显性表达或者直接求解，造成了求解上的困难。因此需要对速度和压力进行解耦，其基本思想是，通过预设的压力场，代入到动量方程中，求解各方向上的速度场；然后根据质量守恒方程构建压力泊松方程，进行压力修正，再进行速度修正，反复迭代，直到达到预设的收敛条件。</p><h2 id="交错网格">交错网格</h2><p>与交错网格相对的是同位网格，再RC插值方法提出之前，压力、速度都存于同一套网格中，共用网格节点。例如x方向的压力梯度项采用中心差分格式:<span class="math display">\[\frac{\partial P}{\partial x} = \frac{P_E - P_W}{2 \delta x}\]</span> 并没有使用到中心节点<span class="math inline">\(P_C\)</span>的值，而在棋盘振荡的压力场时，很容易被认为是无压力梯度，即均匀压力场。造成脱离真实物理的情况。因此交错网格被提出，交错网格中，压力、温度、密度这一类标量存在一套网格中，而各方向上的速度则存在另外一套网格中，速度网格的中心与压力网格中心并不重合，存在一定偏差，速度网格中心一般定义在压力网格面的中心上。如果是均匀网格，则速度网格与压力网格偏差了“半个网格”。交错网格的优势很多，例如速度网格中心在压力网格面上，在求解压力修正方程时，不需要对速度再进行插值。避免了离散压力梯度存在的“棋盘格”问题。但是交错网格的致命缺陷就是使用非常复杂和繁琐，存储成本高，程序编制难度高，边界条件比较难处理，都是致命缺陷。</p><h2 id="稳态二维各向同性流体动力学方程">稳态二维各向同性流体动力学方程</h2><p>二维情况下稳态动力学方程组如下： <span class="math display">\[\frac\partial{\partial x}(\rho uu)+\frac\partial{\partial y}(\rhovu)=\frac\partial{\partial x}\Bigg(\mu\frac{\partial u}{\partialx}\Bigg)+\frac\partial{\partial y}\Bigg(\mu\frac{\partial u}{\partialy}\Bigg)-\frac{\partial p}{\partial x}+S_u\]</span></p><p><span class="math display">\[\frac\partial{\partial x}(\rho uv)+\frac\partial{\partial y}(\rhovv)=\frac\partial{\partial x}\Bigg(\mu\frac{\partial v}{\partialx}\Bigg)+\frac\partial{\partial y}\Bigg(\mu\frac{\partial v}{\partialy}\Bigg)-\frac{\partial p}{\partial y}+S_v\]</span></p><p>连续性方程: <span class="math display">\[\frac\partial{\partial x}(\rho u)+\frac\partial{\partial y}(\rho v)=0\]</span> 其中，对于各向同性的不可压流体而言，密度<span class="math inline">\(\rho\)</span>和粘性系数<span class="math inline">\(\mu\)</span>为常数，可以提出微分符号外，并进一步化简。使用交错网格，即标量、矢量（分量）分别存在一套网格中，彼此错位。但是，在列离散方程时，以变量为核心，以变量所处的网格为依据进行离散。例如，对x方向的动量方程进行离散，所求解的是速度的x分量<span class="math inline">\(u\)</span>，就以<span class="math inline">\(u\)</span>网格为核心进行离散，所使用的网格编号就是<span class="math inline">\(u\)</span>网格的网格编号。</p><p><img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240430225722509.png" alt="image-20240430225722509" style="zoom:50%;"></p><p>上图是交错网格的示意图，对应的是流场内部节点。速度u分量的网格中心(u-cell)，刚好位于标量p(p-cell)网格的左右边界上，速度v分量的网格中心位于标量p网格的上下边界上。交错网格因为网格编号比较复杂，容易搞混，实际上只要记住一点，就可以理清楚三套网格的位置差异，即以行号i，列号j的p-cell网格为基准，行号i，列号j的u-cell网格在p-cell网格的左边界，行号i，列号j的v-cell网格在p-cell网格的右边界。记住这个转换关系就可以理清在程序编写时，同一i,j对于不同网格的相对位置关系。</p><h2 id="动量方程离散">动量方程离散</h2><p>对对流项，采用一阶迎风格式，扩散项采用前向差分格式，注意，因为速度的方向是未知的，并不一定沿着坐标正方向，所以需要写成通用格式离散。首先忽略体积力源项，采用有限体积法对方程左右进行二维情况下的体积分，将方程进行半离散，可得：$$\int {{{\left. {\rho uu} \right|}_e}dy}  - \int {{{\left. {\rho uu} \right|}_w}dy}  + \int {{{\left. {\rho vu} \right|}_n}dx}  - \int {{{\left. {\rho vu} \right|}_s}dx}  = \left( {\int {{{\left. {\mu \frac{{\partial u}}{{\partial x}}} \right|}_e}dy}  - \int {{{\left. {\mu \frac{{\partial u}}{{\partial x}}} \right|}_w}dy} } \right) + \left( {\int {\mu {{\left. {\frac{{\partial u}}{{\partial y}}} \right|}_n}dx}  - \int {\mu {{\left. {\frac{{\partial u}}{{\partial y}}} \right|}_s}dx} } \right) + \int { - \frac{{\partial p}}{{\partial x}}dxdy} $$将对流项和扩散项进行合并，再进行离散，以从u-cell右侧界面流入网格的通量为例：$$\int {{{\left. {\rho uu} \right|}_e}dy}  - \int {{{\left. {\mu \frac{{\partial u}}{{\partial x}}} \right|}_e}dy}  = \left( {\left( {\frac{{{{\left| {\rho {u_{n - 1}}} \right|}_e} + {{\left. {\rho {u_{n - 1}}} \right|}_e}}}{2}} \right){u_P} - \left( {\frac{{{{\left| {\rho {u_{n - 1}}} \right|}_e} + {{\left. {\rho {u_{n - 1}}} \right|}_e}}}{2}} \right){u_E} - \frac{{{u_{E - }}{u_P}}}{{\Delta x}}} \right)\Delta y$$</p>上式中，$\rho u_{n-1}$为质量通量，由于原本的$\rho u u$为非线性项，直接迭代较为困难。所以这里采用延迟修正，即使用上一步迭代计算得到的速度，来计算质量通量。当迭代残差越小时，上一步迭代的结果越接近当前迭代步计算得到的结果，实现一种类似“追赶”效果，直到两者误差在可接受范围内。$u_P$为当前u-cell网格中的u速度，$u_E$为右侧u-cell中心的u速度。$\int {{{\left. {\rho uu} \right|}_e}dy}$采用一阶迎风格式进行离散。而$\int {{{\left. {\mu \frac{{\partial u}}{{\partial x}}} \right|}_e}dy}$则使用了前向差分，一阶格式进行离散得到。这里$\mu$被认为是一个常数，简化了运算，否则，$\mu$实际上需要被当做一个场量来处理，需要通过紧邻点的$\mu$值得到。<p>注意<span class="math inline">\(\rhou_{n-1}\)</span>是u-cell右侧边界上的通量值，它仍然需要通过插值来获得，如下图所示：</p><p><img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240430235703587.png" alt="image-20240430235703587" style="zoom:50%;"></p><p>通过对界面邻近网格的体心值进行插值可以得到界面上的值： <span class="math display">\[\rho u_{n-1} = \rho\frac{u_P^{n-1} + u_E^{n-1}}{2}\]</span> 因为流体是均质不可压流体，密度被设为常数。</p><p>同理可得其余项的离散方程： $$\int {{{\left. {\rho uu} \right|}_w}dy}  - \int {{{\left. {\mu \frac{{\partial u}}{{\partial x}}} \right|}_w}dy}  = \left( {\left( {\frac{{{{\left| {\rho {u_{n - 1}}} \right|}_w} + {{\left. {\rho {u_{n - 1}}} \right|}_w}}}{2}} \right){u_W} - \left( {\frac{{{{\left| {\rho {u_{n - 1}}} \right|}_e} - {{\left. {\rho {u_{n - 1}}} \right|}_e}}}{2}} \right){u_P} - \frac{{{u_{P - }}{u_W}}}{{\Delta x}}} \right)\Delta y$$$$\int {{{\left. {\rho vu} \right|}_n}dy}  - \int {{{\left. {\mu \frac{{\partial u}}{{\partial y}}} \right|}_n}dx}  = \left( {\left( {\frac{{{{\left| {\rho {v_{n - 1}}} \right|}_n} + {{\left. {\rho {v_{n - 1}}} \right|}_n}}}{2}} \right){u_P} - \left( {\frac{{{{\left| {\rho {v_{n - 1}}} \right|}_n} - {{\left. {\rho {v_{n - 1}}} \right|}_n}}}{2}} \right){u_P} - \frac{{{u_{N - }}{u_P}}}{{\Delta y}}} \right)\Delta x$$$$\int {{{\left. {\rho vu} \right|}_s}dy}  - \int {{{\left. {\mu \frac{{\partial u}}{{\partial y}}} \right|}_s}dx}  = \left( {\left( {\frac{{{{\left| {\rho {v_{n - 1}}} \right|}_s} + {{\left. {\rho {v_{n - 1}}} \right|}_s}}}{2}} \right){u_S} - \left( {\frac{{{{\left| {\rho {v_{n - 1}}} \right|}_s} - {{\left. {\rho {v_{n - 1}}} \right|}_s}}}{2}} \right){u_P} - \frac{{{u_{P - }}{u_S}}}{{\Delta y}}} \right)\Delta x$$ 这里，涉及到<span class="math inline">\(\rhov_{n-1}\)</span>，需要找到对应的v-cell网格进行插值得到，如下图所示：</p><figure><img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240501001329715.png" alt="image-20240501001329715"><figcaption aria-hidden="true">image-20240501001329715</figcaption></figure><p>蓝色为v-cell，红色为u-cell，u-cell的上下界面的质量通量，，假定<span class="math inline">\(u_P\)</span>的网格索引号为i,j，则对应到v-cell网格中的索引如下，<span class="math inline">\(\rhov_{n-1}\)</span>通过相邻v-cell的体心值插值获得: <span class="math display">\[\rho v_{n-1}|_{s}=\rho\frac{v_P+v_W}{2}=\rho\frac{v_{i,j}+v_{i,j-1}}{2}\]</span></p><p><span class="math display">\[\rhov_{n-1}|_{n}=\rho\frac{v_N+v}{2}=\rho\frac{v_{i+1,j}+v_{i+1,j-1}}{2}\]</span></p><p>最后是压力梯度项的离散，这里需要说明，虽然此处是对压力梯度进行离散，但是求解的变量为u，以u-cell的位置为基准进行离散，这里体现出一个交错网格的优势，它十分巧妙的让几套网格的中心落在边界上。u-cell的中心，其实是压力网格的左边界。因此以u-cell为中心的压力梯度离散，可以直接采用p-cell的体心值前向差分得到，不需要像上述过程在边界处再插值：<span class="math display">\[\int \frac{\partial p}{\partial x}dxdy= (P_P-P_W)\Delta y\]</span>同理对y方向上的动量方程也进行上述离散过程，不再赘述。对上述格式进行整理可以获得:</p>$$a_{{i,\tilde{f}}}u_{{i,\tilde{f}}}=\sum a_{nb}u_{nb}-({p_{I,\tilde{f}}-p_{I-1,\tilde{f}}})\Delta y$$<p><span class="math display">\[a_{I,j}v_{I,j}=\sum a_{nb}v_{nb}+(p_{I,j-1}-p_{I,j})\Delta x\]</span></p><h2 id="simple算法速度和压力修正">SIMPLE算法速度和压力修正</h2><p>接下来是SIMPLE算法的核心步骤：</p><p>假定<span class="math inline">\(u^*\)</span>和<span class="math inline">\(v^*\)</span>为某一迭代步计算后得到的解，则有(<span class="math inline">\(A_{ij}\)</span>即<span class="math inline">\(\Delta x\)</span>、<span class="math inline">\(\Delta y\)</span>)： <span class="math display">\[a_{i,f}u_{i,f}^*=\suma_{nb}u_{nb}^*+(p_{I-1,f}^*-p_{I,f}^*)A_{i,f}+b_{i,f}\]</span></p><p><span class="math display">\[a_{I,j}v_{I,j}^*=\suma_{nb}v_{nb}^*+(p_{I,j-1}^*-p_{I,j}^*)A_{I,j}+b_{I,j}\]</span></p><p>将上式与假定的收敛解做差，可得: $$a_{{i,j}}(u_{{i,j}}-u_{{i,j}}^{*})=\sum a_{nb}(u_{nb}-u_{nb}^{*})+[(p_{{I-1,j}}-p_{{I-1,j}}^{*})-(p_{{I,j}}-p_{{I,j}}^{*})]A_{{i,j}}$$</p><p><span class="math display">\[a_{I,j}(v_{I,j}-v_{I,j}^{*})=\suma_{nb}(v_{nb}-v_{nb}^{*})+[(p_{I,j-1}-p_{I,j-1}^{*})-(p_{I,j}-p_{I,j}^{*})]A_{I,j}\]</span></p><p>进一步简写可以得到: <span class="math display">\[a_{i,j}u_{i,j}^{\prime}=\suma_{nb}u_{nb}^{\prime}+(p_{I-1,j}^{\prime}-p_{I,j}^{\prime})A_{i,j}\\a_{I,j}v_{I,j}^{\prime}=\suma_{nb}v_{nb}^{\prime}+(p_{I,j-1}^{\prime}-p_{I,j}^{\prime})A_{I,j}\]</span> 上式中，<span class="math inline">\(u_{i,j}^{\prime}\)</span>和<span class="math inline">\(v_{I,j}^{\prime}\)</span>则分别是u-cell和v-cell速度修正值，因此速度的更新，则由迭代值<span class="math inline">\(u^*\)</span>和<span class="math inline">\(u^{\prime}\)</span>决定：</p><p><span class="math display">\[u=u^*+u^{\prime}\]</span></p><p><span class="math display">\[v=v^{*}+v^{\prime}\]</span></p><p>上式中，<span class="math inline">\(\suma_{nb}(u_{nb}-u_{nb}^{*})\)</span>为相邻网格节点对速度修正值的影响。SIMPLE算法在迭代过程中，将这一值忽略，即速度修正仅与压力修正值有关。这样做，近邻点无法显性表达，直接迭代处理较为麻烦，二是，随着速度逐渐收敛，近邻点的影响逐渐减弱，直到“忽略不计”，并不会影响最终的结果：<span class="math display">\[u_{i,j}^{\prime}=d_{i,j}(p_{I-1,j}^{\prime}-p_{I,j}^{\prime})\\v_{I,j}^{\prime}=d_{I,j}(p_{I,j-1}^{\prime}-p_{I,j}^{\prime})\]</span></p><p><span class="math display">\[u_{i,j}=u_{i,j}^*+d_{i,j}(p_{i-1,j}^\prime-p_{i,j}^\prime)\]</span></p><p><span class="math display">\[v_{I,j}=v_{I,j}^*+d_{I,j}(p_{I,j-1}^{\prime}-p_{I,j}^{\prime})\]</span></p><p>到这一步，我们终于把压力修正值与速度修正值联系起来了。可是仅靠动量方程，我们还是无法得到将两者求解出来。这时，还剩下连续性方程，连续性方程没有压力表达式的参与，仅由速度和密度决定。更像是一个准确性判据，即速度必须需要满足连续性方程，才是符合物理解的方程。<span class="math display">\[[(\rho uA)_{i+1,j}-(\rho uA)_{i,j}]+[(\rho vA)_{I,j+1}-(\rhovA)_{I,j}]=0\]</span> 将u和v的迭代表达式代入上述方程，可以得到压力泊松方程： <span class="math display">\[\begin{aligned}&amp;[\rho_{i+1,j}A_{i+1,j}(u_{i+1,j}^{*}+d_{i+1,j}(p_{I,j}^{\prime}-p_{I+1,j}^{\prime}))-\rho_{i,j}A_{i,j}(u_{i,j}^{*}\\&amp;+d_{i,j}(p_{I-1,j}^{\prime}-p_{I,j}^{\prime}))]+[\rho_{I,j+1}A_{I,j+1}(v_{I,j+1}^{*}+d_{I,j+1}(p_{I,j}^{\prime}-p_{I,j+1}^{\prime}))\\&amp;-\rho_{I,j}A_{I,j}(v_{I,j}^{*}+d_{I,j}(p_{I,j-1}^{\prime}-p_{I,j}^{\prime}))]=0\end{aligned}\]</span> 进一步化简得到： <span class="math display">\[a_{I,j}p_{I,j}^{\prime}=a_{I+1,j}p_{I+1,j}^{\prime}+a_{I-1,j}p_{I-1,j}^{\prime}+a_{I,j+1}p_{I,j+1}^{\prime}+a_{I,j-1}p_{I,j-1}^{\prime}+b_{I,j}^{\prime}\]</span> <img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240502103211242.png" alt="image-20240502103211242"></p><p>压力泊松方程，求解的是各个节点上的压力修正值。仍然是需要迭代求解，并非显性可以直接递推获得全域的压力修正值。</p><h2 id="边界条件">边界条件</h2><p>边界条件应该是交错网格中，最容易让人误判的地方，参考书目中对边界条件讲的并不太多。首先，这是与交错网格划分方式相关。一般而言，对于真实流体域划分网格，以标量网格为核心，速度网格再错开。如下图所示：</p><figure><img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240502104639564.png" alt="image-20240502104639564"><figcaption aria-hidden="true">image-20240502104639564</figcaption></figure><p>以压力网格为核心，速度网格u和v相对于p网格中心进行偏移。对于无滑移边界条件而言，边界上的速度值已经给定，而u和v的边界网格中心，刚好落在物理边界上。所以直接对速度网格赋予边界值，在求解压力泊松方程。</p><p>而对于p网格，其边界条件的确定，则对应到压力泊松方程，具体参考汪洋博士的开源文档（B站名：大官人学CFD）。</p><p>本文所使用的网格划分方式，与上述方式略有不用，更"类似"于有限差分法的网格划分方式，即p-cell的中心在物理边界上，导致边界上的速度网格向外延伸，超出边界成为虚拟网格。</p><figure><img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240502183914471.png" alt="image-20240502183914471"><figcaption aria-hidden="true">image-20240502183914471</figcaption></figure><p>对于u网格（上图中红色网格）：</p><p>u网格在左右边界向外延伸出一个虚拟网格节点，而在上下边界中，则u-cell中心落在边界上，因此对于无滑移边界或者速度给定的边界条件，则，上下边界的u-cell网格可以直接给定速度值。而对于左右边界，超出实际物理边界的虚拟边界网格的赋值，则认为与内层节点互为相反数（对于无滑移边界）。因为物理边界实际处于虚拟节点与内层节点的中心位置，u=0，所以根据插值关系得到虚拟节点的赋值与内层节点的计算值互为相反数。</p><p>对于v网格（上图中蓝色网格）：</p><p>与u网格处理方式极为相似，不同的是，计算域左右物理边界，刚好处于v网格的中心位置，所以可以直接赋值。而上下边界处，v网格向外延伸出一层虚拟节点，和u网格处理方法一致，在无滑移边界条件下，边界虚拟网格节点的值与内层网格节点值互为相反数。</p><p>对于p网格（上图中黑色网格）：</p><p>对于p网格，要分情况讨论，还是要落到原本的压力修正方程中。四个角点的p网格，首先考虑到，压力是一个相对意义大于绝对意义的物理量，CFD计算中关注压差，而非绝对压力，压差是驱动流体运动的关键。计算压力需要设置一个压力参考点，由于上边界设定为速度边界，所以习惯性设定左下角角点处的压力为0，作为一个计算参考值。</p><p>紧接着对于其余3个角点，将网格边界上的通量代入到原本压力修正方程中，可以得到，对于右下角角点，AE=0，AS=0。左上角角点，AW=0，AN=0。右上角角点，AN=0，AE=0。</p><p>然后是除角点外的边界网格，对于左边界，AW=0；右边界，AE=0；上边界，AN=0；下边界,AS = 0。</p><p>最后是SIMPLE算法的流程：</p><figure><img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240502190203547.png" alt="image-20240502190203547"><figcaption aria-hidden="true">image-20240502190203547</figcaption></figure><h2 id="计算程序">计算程序</h2><p>以二维驱动方腔流动为例，编写程序，实现使用有限体积法和交错网格计算方腔内的速度和压力分布（个人觉得最难的部分，其实还是在于边界条件的理解上）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><code class="hljs pytho">#!/usr/bin/env python3<br># -*- coding: utf-8 -*-<br>&quot;&quot;&quot;<br>Created on Sun Apr 28 09:46:16 2024<br><br>@author: mestro<br>&quot;&quot;&quot;<br>from math import *<br>import numpy as np<br>import matplotlib.pyplot as plt<br><br><br>L = 1.0<br>N = 51<br>dx = L/(N-1)<br>dy = L/(N-1)<br>velocity = 2.0<br>rho = 1<br>miu = 0.01<br><br>P = np.zeros([N,N])<br>U = np.zeros([N,N+1])<br>V = np.zeros([N+1,N])<br>U[N-1,:] = velocity<br>dU = np.zeros([N,N+1])<br>dV = np.zeros([N+1,N])<br><br><br>P_iter = P.copy()<br>U_iter = U.copy()<br>V_iter = V.copy()<br><br>NN = N*N<br>iter = 0<br>err = 1.0<br><br>while (iter &lt; 1000) and (err &gt; 1e-5):<br>    for i in range(1,N-1):<br>        for j in range(1,N):<br>            rho_u_e = 0.5*(U[i,j] + U[i,j+1])*rho;<br>            rho_u_w = 0.5*(U[i,j] + U[i,j-1])*rho;<br>            rho_v_s = 0.5*(V[i,j] + V[i,j-1])*rho;<br>            rho_v_n = 0.5*(V[i+1,j] + V[i+1,j-1])*rho;<br>            <br>            AE = 0.5*(abs(rho_u_e) + rho_u_e)*dy + miu*dy/dx;<br>            AW = 0.5*(abs(rho_u_w) - rho_u_w)*dy + miu*dy/dx;<br>            AN = 0.5*(abs(rho_v_n) + rho_v_n)*dx + miu*dx/dy;<br>            AS = 0.5*(abs(rho_v_s) - rho_v_s)*dx + miu*dx/dy;<br>            <br>            AEE = 0.5*(abs(rho_u_e) - rho_u_e)*dy + miu*dy/dx;<br>            AWW = 0.5*(abs(rho_u_w) + rho_u_w)*dy + miu*dy/dx;<br>            ANN = 0.5*(abs(rho_v_n) - rho_v_n)*dx + miu*dx/dy;<br>            ASS = 0.5*(abs(rho_v_s) + rho_v_s)*dx + miu*dx/dy;<br>            <br>            Ap = (AE+AW+AN+AS);<br>            U_iter[i,j] = 1/Ap*(AEE*U[i,j+1] + AWW*U[i,j-1] + ANN*U[i+1,j] + ASS*(U[i-1,j]) - (P[i,j] - P[i,j-1])*dy);<br>            dU[i,j] = dy/Ap;<br>    #bottom mesh<br>    i = 0;<br>    for j in range(1,N):<br>        rho_u_e = 0.5*(U[i,j] + U[i,j+1])*rho;<br>        rho_u_w = 0.5*(U[i,j] + U[i,j-1])*rho;<br>        #rho_v_s = 0.5*(V[i,j] + V[i,j-1])*rho;<br>        rho_v_n = 0.5*(V[i+1,j] + V[i+1,j-1])*rho;<br>        <br>        AE = 0.5*(abs(rho_u_e) + rho_u_e)*dy + miu*dy/dx;<br>        AW = 0.5*(abs(rho_u_w) - rho_u_w)*dy + miu*dy/dx;<br>        AN = 0.5*(abs(rho_v_n) + rho_v_n)*dx + miu*dx/dy;<br>        #AS = 0.5*(abs(rho_v_s) - rho_v_s)*dx + miu*dx/dy;<br>        As = 0;<br>        Ap = (AE+AW+AN+AS);<br>        dU[i,j] = dy/Ap;<br>    #top mesh<br>    i = N-1<br>    for j in range(1,N):<br>        rho_u_e = 0.5*(U[i,j] + U[i,j+1])*rho;<br>        rho_u_w = 0.5*(U[i,j] + U[i,j-1])*rho;<br>        rho_v_s = 0.5*(V[i,j] + V[i,j-1])*rho;<br>        #rho_v_n = 0.5*(V[i+1,j] + V[i+1,j-1])*rho;<br>        <br>        AE = 0.5*(abs(rho_u_e) + rho_u_e)*dy + miu*dy/dx;<br>        AW = 0.5*(abs(rho_u_w) - rho_u_w)*dy + miu*dy/dx;<br>        #AN = 0.5*(abs(rho_v_n) + rho_v_n)*dx + miu*dx/dy;<br>        AN = 0.0;<br>        AS = 0.5*(abs(rho_v_s) - rho_v_s)*dx + miu*dx/dy;<br>        Ap = (AE+AW+AN+AS);<br>        dU[i,j] = dy/Ap;<br>    #Apple BCs<br>    U_iter[:,0] = -U_iter[:,1]; #left<br>    U_iter[1:N-1,N] = -U_iter[1:N-1,N-1]; #right<br>    U_iter[0,:] = 0.0 #bottom<br>    U_iter[N-1,:] = velocity #top<br>    <br>    <br>    # V equation<br>    for i in range(1,N):<br>        for j in range(1,N-1):<br>            rho_u_e = 0.5*(U[i,j] + U[i-1,j])*rho;<br>            rho_u_w = 0.5*(U[i,j+1] + U[i-1,j+1])*rho;<br>            rho_v_n = 0.5*(V[i,j] + V[i+1,j])*rho;<br>            rho_v_s = 0.5*(V[i,j] + V[i-1,j])*rho;<br>            <br>            AE = 0.5*(abs(rho_u_e) + rho_u_e)*dy + miu*dy/dx;<br>            AW = 0.5*(abs(rho_u_w) - rho_u_w)*dy + miu*dy/dx;<br>            AN = 0.5*(abs(rho_v_n) + rho_v_n)*dx + miu*dx/dy;<br>            AS = 0.5*(abs(rho_v_s) - rho_v_s)*dx + miu*dx/dy;<br>            <br>            AEE = 0.5*(abs(rho_u_e) - rho_u_e)*dy + miu*dy/dx;<br>            AWW = 0.5*(abs(rho_u_w) + rho_u_w)*dy + miu*dy/dx;<br>            ANN = 0.5*(abs(rho_v_n) - rho_v_n)*dx + miu*dx/dy;<br>            ASS = 0.5*(abs(rho_v_s) + rho_v_s)*dx + miu*dx/dy;<br>            <br>            Ap = (AE+AW+AN+AS);<br>            V_iter[i,j] = 1.0/Ap*(AEE*V[i,j+1] + AWW*V[i,j-1] + ANN*V[i+1,j] + ASS*V[i-1,j] - (P[i,j] - P[i-1,j])*dx);<br>            dV[i,j] = dx/Ap;<br>    #left<br>    j = 0<br>    for i in range(1,N):<br>        rho_u_e = 0.5*(U[i,j] + U[i-1,j])*rho;<br>        #rho_u_w = 0.5*(U[i,j+1] + U[i-1,j+1])*rho;<br>        rho_v_n = 0.5*(V[i,j] + V[i+1,j])*rho;<br>        rho_v_s = 0.5*(V[i,j] + V[i-1,j])*rho;<br>        <br>        AE = 0.5*(abs(rho_u_e) + rho_u_e)*dy + miu*dy/dx;<br>        #AW = 0.5*(abs(rho_u_w) - rho_u_w)*dy + miu*dy/dx;<br>        AW = 0.0<br>        AN = 0.5*(abs(rho_v_n) + rho_v_n)*dx + miu*dx/dy;<br>        AS = 0.5*(abs(rho_v_s) - rho_v_s)*dx + miu*dx/dy;<br>        Ap = (AE+AW+AN+AS);<br>        dV[i,j] = dx/Ap;<br>    <br>    #right0, L, N<br>    j = N-1<br>    for i in range(1,N):<br>        #rho_u_e = 0.5*(U[i,j] + U[i-1,j])*rho;<br>        rho_u_w = 0.5*(U[i,j+1] + U[i-1,j+1])*rho;<br>        rho_v_n = 0.5*(V[i,j] + V[i+1,j])*rho;<br>        rho_v_s = 0.5*(V[i,j] + V[i-1,j])*rho;<br>        <br>        #AE = 0.5*(abs(rho_u_e) + rho_u_e)*dy + miu*dy/dx;<br>        AE = 0.0;<br>        AW = 0.5*(abs(rho_u_w) - rho_u_w)*dy + miu*dy/dx;<br>        AN = 0.5*(abs(rho_v_n) + rho_v_n)*dx + miu*dx/dy;<br>        AS = 0.5*(abs(rho_v_s) - rho_v_s)*dx + miu*dx/dy;<br>        Ap = (AE+AW+AN+AS);<br>        dV[i,j] = dx/Ap;<br>    #Apply BCs<br><br>    V_iter[:,0] = 0.0;<br>    V_iter[:,N-1] = 0.0;<br>    V_iter[0,1:N-1] = -V_iter[1,1:N-1];<br>    V_iter[N,1:N-1] = -V_iter[N-1,1:N-1];<br>    <br>    U_old = U.copy();<br>    V_old = V.copy();<br>    bp = np.zeros([NN,1]);<br>    #pressure fix<br>    for i in range(N):<br>        for j in range(N):<br>            index = i*N+j;<br>            bp[index] = (rho*U_iter[i,j]*dy - rho*U_iter[i,j+1]*dy + rho*V_iter[i,j]*dx - rho*V_iter[i+1,j]*dx);<br>    bp[0] = 0.0;<br>    <br>    APP = np.zeros([NN,NN]);<br>    #left bottom<br>    i = 0<br>    j = 0<br>    index = i*N + j<br>    # Ae = -rho*dU[i,j+1]*dy;<br>    # An = -rho*dV[i+1,j]*dx;<br>    # Ap = -(Ae + An);<br>    # APP[index,index+1] = Ae;<br>    # APP[index,index+N] = An;<br>    # APP[index,index] = Ap;<br>    APP[index,index] = 1;<br>    <br>    #right bottom<br>    i = 0;<br>    j = N-1;<br>    index = i*N + j<br>    Aw = -rho*dU[i,j]*dy;<br>    An = -rho*dV[i+1,j]*dx;<br>    Ap = -(Aw + An);<br>    APP[index,index - 1] = Aw;<br>    APP[index,index + N] = An;<br>    APP[index,index] = Ap;<br>    <br>    #left top<br>    i = N-1<br>    j = 0;<br>    index = i*N + j<br>    As = -rho*dV[i,j]*dx;<br>    Ae = -rho*dU[i,j+1]*dy;<br>    Ap = -(As + Ae);<br>    APP[index,index+1] = Ae;<br>    APP[index,index-N] = As;<br>    APP[index,index] = Ap;<br>    <br>    #right top<br>    i = N-1<br>    j = N-1<br>    index = i*N+j<br>    Aw = -rho*dU[i,j]*dy;<br>    As = -rho*dV[i,j]*dx;<br>    Ap = -(Aw + As);<br>    APP[index,index] = Ap<br>    APP[index,index-1] = Aw<br>    APP[index,index-N] = As <br><br>    i = 0;<br>    for j in range(1,N-1):<br>        index = i*N+j;<br>        Aw = -rho*dU[i,j]*dy;<br>        An = -rho*dV[i+1,j]*dx;<br>        Ae = -rho*dU[i,j+1]*dy;<br>        Ap = -(Aw + An + Ae);<br>        APP[index,index] = Ap;<br>        APP[index,index-1] = Aw;<br>        APP[index,index+N] = An;<br>        APP[index,index+1] = Ae;<br>        <br>        <br>        <br>    i = N-1;<br>    for j in range(1,N-1):<br>        index = i*N+j<br>        Aw = -rho*dU[i,j]*dy;<br>        As = -rho*dV[i,j]*dx;<br>        Ae = -rho*dU[i,j+1]*dy;<br>        Ap = -(Aw + As + Ae);<br>        APP[index,index] = Ap;<br>        APP[index,index - 1] = Aw;<br>        APP[index,index - N] = As;<br>        APP[index,index + 1] = Ae;<br>    <br>    j = 0;<br>    for i in range(1,N-1):<br>        index = i*N+j;<br>        Ae = -rho*dU[i,j+1]*dy;<br>        An = -rho*dV[i+1,j]*dx;<br>        As = -rho*dV[i,j]*dx;<br>        Ap = -(Ae + An + As);<br>        APP[index,index] = Ap;<br>        APP[index,index + 1] = Ae;<br>        APP[index,index + N] = An;<br>        APP[index,index - N] = As;<br>    <br>    j = N-1;<br>    for i in range(1,N-1):<br>        index = i*N + j;<br>        Aw = -rho*dU[i,j]*dy;<br>        An = -rho*dV[i+1,j]*dx;<br>        As = -rho*dV[i,j]*dx;<br>        Ap = -(Aw + An + As);<br>        APP[index,index] = Ap;<br>        APP[index,index - 1] = Aw;<br>        APP[index,index + N] = An;<br>        APP[index,index - N] = As;<br>    <br>    for i in range(1,N-1):<br>        for j in range(1,N-1):<br>            index = i*N + j<br>            Aw = -rho*dU[i,j]*dy;<br>            An = -rho*dV[i+1,j]*dx;<br>            As = -rho*dV[i,j]*dx;<br>            Ae = -rho*dU[i,j+1]*dy;<br>            Ap = -(Aw + An + As + Ae);<br>            APP[index,index] = Ap;<br>            APP[index,index - 1] = Aw;<br>            APP[index,index + N] = An;<br>            APP[index,index - N] = As;<br>            APP[index,index + 1] = Ae;<br>            <br>            <br>    # pressure correction<br>    p_fix = np.linalg.solve(APP, bp)<br>    P_fix_matrix = np.zeros([N,N]);<br>    for i in range(N):<br>        for j in range(N):<br>            index = i*N+j<br>            P[i,j] = 0.3*p_fix[index] + P[i,j];<br>            P_fix_matrix[i,j] = p_fix[index];<br>    P[0,0] = 0.0;<br>    #velocity update<br>    for i in range(1,N-1):<br>        for j in range(1,N):<br>            U[i,j] = U_iter[i,j] + dU[i,j]*(P_fix_matrix[i,j-1] - P_fix_matrix[i,j]);<br>    for i in range(1,N):<br>        for j in range(1,N-1):<br>            V[i,j] = V_iter[i,j] + dV[i,j]*(P_fix_matrix[i-1,j] - P_fix_matrix[i,j]);<br>    <br>    <br>    #Apple BCs<br>    U[1:N-1,0] = -U[1:N-1,1]; #left<br>    U[1:N-1,N] = -U[1:N-1,N-1]; #right<br>    U[0,:] = 0.0 #bottom<br>    U[N-1,:] = velocity #top<br>    <br>    V[0,1:N-1] = -V[1,1:N-1];<br>    V[N,1:N-1] = -V[N-1,1:N-1];<br>    V[:,0] = 0.0;<br>    V[:,N-1] = 0.0;<br>    <br>    err1 = np.max(np.abs(U-U_old))<br>    err2 = np.max(np.abs(V-V_old))<br>    err = max(err1,err2)<br>    <br>    iter = iter + 1<br>    print(&quot;the iter num is &quot; + str(iter) + &quot; and max err is &quot; + str(err) + &quot;\n&quot;)<br>    <br><br><br>#plot<br>x = np.linspace(dx/2, 1 - dx/2,N-1);<br>y = np.linspace(0, 1, N)<br>X, Y = np.meshgrid(x, y)  # Generate 2D grid coordinates<br>plt.figure()<br>plt.contourf(X,Y, U[:,1:N], levels=20, cmap=&#x27;jet&#x27;)  # Adjust levels and cmap as needed<br>plt.colorbar(label=&#x27;Velocity UX&#x27;)<br>plt.xlabel(&#x27;X&#x27;)<br>plt.ylabel(&#x27;Y&#x27;)<br>plt.title(&#x27;Velocity Contour Plot&#x27;)<br>plt.show()<br><br><br>x = np.linspace(0,1,N);<br>y = np.linspace(0, 1, N)<br>X, Y = np.meshgrid(x, y)  # Generate 2D grid coordinates<br>plt.figure()<br>plt.contourf(X,Y,P, levels=20, cmap=&#x27;jet&#x27;)  # Adjust levels and cmap as needed<br>plt.colorbar(label=&#x27;pressure P&#x27;)<br>plt.xlabel(&#x27;X&#x27;)<br>plt.ylabel(&#x27;Y&#x27;)<br>plt.title(&#x27;Pressure&#x27;)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240502190416634.png" alt="image-20240502190416634"><figcaption aria-hidden="true">image-20240502190416634</figcaption></figure><figure><img src="https://bihengnew-1259679794.cos.ap-nanjing.myqcloud.com/image-20240502190443074.png" alt="image-20240502190443074"><figcaption aria-hidden="true">image-20240502190443074</figcaption></figure><h2 id="小结">小结</h2><p>本文主要是使用Python实现了基于有限体积法和交错网格的SIMPLE算法，对流项采用一阶迎风格式，扩散项采用前向差分，其实离散过程并不复杂，最复杂和最难分清楚的还是在于边界条件，个人觉得这也是书中讲述比较少的地方。文中有错误非常欢迎指出，尤其是理解上和原则性错误。</p><p>参考资料：</p><ol type="1"><li>B站 曾导SJTU的CFD从0到1的课程</li><li>B站 大官人学CFD，汪洋博士的开源OpenFOAM基础课程讲义</li><li>参考书：An Introduction to Computational Fluid Dynamics The FiniteVolume Method 2nd Edition.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Openfoam学习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenFOAM基础 - c++ note1</title>
      <link href="/2023/11/01/post04/"/>
      <url>/2023/11/01/post04/</url>
      
        <content type="html"><![CDATA[<h1 id="c20的学习----碎碎念01">c++20的学习 -- 碎碎念01</h1><p>这篇文章并不是深入学习C++的总结，只是为了记录在学习C++过程中的练习和代码，熟悉C++20的一些新特性与编程方法。对于C++而言，最重要的是设计模式，类的构思，将大型项目化整为零的能力。</p><h2 id="静态链接库和动态链接库">静态链接库和动态链接库</h2><p>静态链接库和动态链接库都是C++函数的具体实现，一般要配合相应的库头文件使用。这种做法维护了函数的具体实现不被外界获知，也使开发者不用去纠结函数的具体实现而是专注在上层结构的开发中，便于使程序整体清晰、解耦。但是静态链接库和动态链接库在使用方法上还是有很大区别：</p><ul><li>静态链接库在编译时被链接到程序中，因此也被称为静态库。当程序被编译链接时，静态链接库的代码会被全部复制到生成的可执行文件中。优点是程序的运行不依赖于外部的库文件，可以在没有额外依赖的情况下在不同的环境中运行。缺点：每个使用该静态库的程序都会包含一份静态库的副本，导致可执行文件的大小增加，并且占用更多的内存空间。</li><li>动态链接库在程序运行时被加载到内存中，因此也被称为共享库。程序在运行时会动态地链接到动态链接库中的函数和资源。优点是减小了可执行文件的大小，节约了内存空间，而且如果多个程序使用同一个动态链接库，那么系统只需要加载一份该库的副本，节约了系统资源。缺点是程序的运行依赖于外部的库文件，如果某个动态链接库被删除或损坏，那么依赖于它的程序将无法正常运行。</li></ul><h3 id="如何在mac中使用库文件来构建程序">如何在Mac中使用库文件来构建程序</h3><p>首先给出一个基本的程序，这个程序是调用了外部的函数，所以需要将外部函数生成链接库的形式：</p><p>hello.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;add.hpp&quot;</span> <span class="hljs-comment">//外部函数头文件</span></span><br></code></pre></td></tr></table></figure><p>hello.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;hello.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(a,b)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>外部函数add.hpp头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>外部函数add.cpp头文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;add.hpp&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先使用clang++将外部函数编译成函数链接库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang++ -std=c++20 -shared -o libadd.dylib add.cpp<br></code></pre></td></tr></table></figure><p>其中，-shared指令表示生成共享链接库，就是动态链接库，如果是静态链接库，就是-static，然后就是编译过程中引用外部链接库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang++ -std=c++20 -I ./ hello.cpp -L./ -ladd -o hello<br></code></pre></td></tr></table></figure><p>注意，这其中-I、-L、-l的作用有差异，作用如下（chatgpt）：</p><p>在使用 g++编译器时，可以通过不同的选项来指定库文件和头文件的位置，其中<code>-L</code>、<code>-l</code> 和 <code>-I</code>是常用的选项，它们分别表示如下意思：</p><ol type="1"><li><code>-L</code> 选项：<ul><li><code>-L</code>选项用于指定库文件的搜索路径，告诉编译器在哪里寻找要链接的库文件。</li><li>例如，如果你的库文件位于 <code>/path/to/lib</code>目录下，你可以使用 <code>-L/path/to/lib</code>来告诉编译器在该目录下寻找库文件。</li></ul></li><li><code>-l</code> 选项：<ul><li><code>-l</code> 选项用于指定要链接的库文件的名称，通常是去掉开头的<code>lib</code> 前缀和文件扩展名的部分。</li><li>例如，如果你要链接的库文件为 <code>libexample.a</code> 或<code>libexample.so</code>，你可以使用 <code>-lexample</code>来告诉编译器链接这个库文件。</li></ul></li><li><code>-I</code> 选项：<ul><li><code>-I</code>选项用于指定头文件的搜索路径，告诉编译器在哪里寻找包含文件（头文件）。</li><li>例如，如果你的头文件位于 <code>/path/to/include</code>目录下，你可以使用 <code>-I/path/to/include</code>来告诉编译器在该目录下寻找头文件。</li></ul></li></ol><p>综上所述，<code>-L</code> 用于指定库文件的搜索路径，<code>-l</code>用于指定要链接的库文件的名称，而 <code>-I</code>用于指定头文件的搜索路径。这些选项可以帮助编译器正确地找到并链接需要的库文件和头文件，从而顺利完成程序的编译过程。</p><h2 id="函数重载">函数重载</h2><p>函数重载是重要内容，在C++中应用广泛。声明一个函数需要返回值类型 +函数名 +参数列表，由于C++中每一个变量都必须说明变量的类型，是浮点型、整数型还是字符类型等。所以对应不同的输入参数，如果函数要实现的功能又一致的话，就需要进行函数重载。函数重载有三条限制：</p><ul><li>被重载的函数具有相同的函数名</li><li>参数列表不同：被重载的函数必须具有不同的参数列表。参数列表可以通过参数的类型、参数的顺序或参数的个数来区分。</li><li>返回类型不同不足以进行重载：函数的返回类型不会被视为函数重载的一部分。如果两个函数具有相同的参数列表，但是返回类型不同，将无法进行重载。</li></ul><p>以下为具体实例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-comment">// void add(int a, int b) 不构成函数重载</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     int c = a+b;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-type">double</span> a1,b1;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cin&gt;&gt;a1&gt;&gt;b1;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(a,b)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(a1,b1)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 程序的输入与输出： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">in</span>:<br>10 10<br>98.5 1.5<br>out:<br>20<br>100<br></code></pre></td></tr></table></figure></p><h2 id="函数模板">函数模板</h2><p>如果每一个不同类型的输入，就要反复重载函数的话，也确实太过于繁琐，因此，采用函数模板可以简化程序，避免大量冗余的代码。通过模板，C++可以根据输入值的类型来反推函数参数的类型，然后将这个函数实例化，变成可以实用的函数。引入模板就已经开始初步涉入泛型编程了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">maximum</span><span class="hljs-params">(T a,T b,T c)</span></span><br><span class="hljs-function"></span>&#123;<br>    T temp=a;<br>    <span class="hljs-keyword">if</span>(a&lt;b)<br>        temp = b;<br>    <span class="hljs-keyword">if</span>(temp&lt;c)<br>        temp = c;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-comment">//多个参数类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T1 a, T2 b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>,b=<span class="hljs-number">11</span>,c=<span class="hljs-number">12</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">maximum</span>(a,b,c)&lt;&lt;endl;<br>    <span class="hljs-type">double</span> a1 = <span class="hljs-number">10.1</span>, b1 = <span class="hljs-number">11.1</span>, c1 = <span class="hljs-number">12.1</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">maximum</span>(a1,b1,c1)&lt;&lt;endl;<br><br>    <span class="hljs-type">int</span> c2  = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">double</span> c3 = <span class="hljs-number">10.1</span>;<br>    <span class="hljs-built_in">print</span>(c2,c3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="数组">数组</h2><p>在c语言中，数组实质是指针，开辟一片连续的内存空间，都需要预先申请内存。C++中，可以使用一些新玩法，新的数据结构。一个是array，一个是vector。其中array是固定数组，类似于在c语言中看到的数组，使用需要引用头文件array。vector是可变向量，使用需要引用头文件vector。无论是array还是vector都是类模板，需要在指定类型后，才能成为一个实际的类。数组的使用，无非是声明，遍历，赋值及修改值，查找和排序。首先以array为例：### 数组的声明及初始化/赋值 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;<span class="hljs-type">int</span>,5&gt; a; <span class="hljs-comment">//输入int表示这是一个整数类型指针，5表示有5个元素</span><br>    array b&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//同样，对于简单数据类型，也可以直接声明，让array去猜去判断数据类型到底是什么</span><br>    <span class="hljs-comment">//接下来是循环遍历</span><br>    <span class="hljs-comment">//第一种方案，类似于普通数组的用法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++) <span class="hljs-comment">//a.size()返回数组元素个数</span><br>    &#123;<br>        a[i] = i+<span class="hljs-number">1</span>;<br>        cout&lt;&lt;a[i]&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;above is the first method&quot;</span>&lt;&lt;endl;<br><br>    <span class="hljs-comment">//第二种方案，使用迭代器</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>(); it!= a.<span class="hljs-built_in">end</span>();it++) <span class="hljs-comment">//auto关键字一般使用来自动判断数据类型的，auto可以简化迭代器的声明</span><br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;endl; <span class="hljs-comment">//这里的it更像是指针</span><br>        *it = *it * <span class="hljs-number">2</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;after: &quot;</span>&lt;&lt;*it&lt;&lt;endl; <br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;above is the second method&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//前面两种，没办法直接判断数组越界</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        cout&lt;&lt;a.<span class="hljs-built_in">at</span>(i)&lt;&lt;endl;<br>        a.<span class="hljs-built_in">at</span>(i) = a.<span class="hljs-built_in">at</span>(i)*<span class="hljs-number">2</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;after: &quot;</span>&lt;&lt;a.<span class="hljs-built_in">at</span>(i)&lt;&lt;endl;<br>        <span class="hljs-comment">//a.at(5)就会抛出异常，在工程代码中非常有用 </span><br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;above is the third method&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test0</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> ### 数组的查找和排序数组array作为模板类，本身也提供了一系列查找方法，可以很方便对数组进行一些操作。在Algorithm库中，有sort函数可以使用，需要给出数组的首尾数据，默认是升序排列。如果要改变排序的方法，可以自己定义排序函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array b&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//初始化一个数组</span><br>    std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//默认升序排列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;item : b)<br>    &#123;<br>        std::cout&lt;&lt;item&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;after the sorting&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b; <span class="hljs-comment">//降序排列函数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array b&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//初始化一个数组</span><br>    std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),cmp); <span class="hljs-comment">//默认升序排列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;item : b)<br>    &#123;<br>        std::cout&lt;&lt;item&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;after the sorting: decend&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array b&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//初始化一个数组</span><br>    std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//默认升序排列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp; item : b)<br>    &#123;<br>        std::cout&lt;&lt;item&lt;&lt;endl;<br>    &#125;<br>    cout &lt;&lt; std::<span class="hljs-built_in">binary_search</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),<span class="hljs-number">6</span>)&lt;&lt;endl;<br>    <span class="hljs-type">bool</span> flag&#123;std::<span class="hljs-built_in">binary_search</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),<span class="hljs-number">10</span>)&#125;; <span class="hljs-comment">//注意，实测降序无法使用二分查找</span><br>    <span class="hljs-keyword">if</span>(flag)<br>        cout&lt;&lt;<span class="hljs-string">&quot;I find it&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;Sorry I cannot find it&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//test1();</span><br>    <span class="hljs-comment">//test2();</span><br>    <span class="hljs-built_in">test3</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>其实还有一个点是多维数组，多维数组本质上是多个降一维度的数组迭加，有一个嵌套的使用在：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个二维数组，3行四列，注意这里声明的时候，行列的位置是反的</span><br>    std::array&lt;std::array&lt;<span class="hljs-type">int</span>, 4&gt;, 3&gt; myArray = &#123;&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>        &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>    &#125;&#125;;<br>    <span class="hljs-comment">// std::array&lt;std::array&lt;int, 4&gt;, 3&gt; myArray&#123;std::array&#123;1, 2, 3, 4&#125;,std::array&#123;5, 6, 7, 8&#125;,std::array&#123;9, 10, 11, 12&#125;&#125;;</span><br>    <span class="hljs-comment">// 访问并输出数组元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>            std::cout &lt;&lt; myArray[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="函数式编程">函数式编程</h2><p>其实函数本身也可以作为“参数”传递给其他函数使用，函数式编程也具有“增量更新”的特性。原本在面向过程的开发流场中，稍微改动一个函数的功能，就要修改变量，可能会引入非常多的错误。C++中的函数编程是指利用函数作为一等公民（First-ClassCitizen）来编写程序，这意味着函数可以像其他类型的数据一样被传递、赋值、返回和操作。函数式编程强调函数的纯粹性和不可变性，鼓励使用无副作用的函数和避免共享状态。</p><p>函数可以作为参量被调用，也可以和函数模板配合： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// // 定义一个需要传入函数作为参数的函数</span><br><span class="hljs-comment">// void performOperation(int x, int y, int (*operation)(int, int)) &#123;</span><br><span class="hljs-comment">//     int result = operation(x, y);</span><br><span class="hljs-comment">//     std::cout &lt;&lt; &quot;The result is: &quot; &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 定义一个函数，用于相加</span><br><span class="hljs-comment">// int add(int a, int b) &#123;</span><br><span class="hljs-comment">//     return a + b;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 定义一个函数，用于相乘</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt; <span class="hljs-comment">//函数模板，不指定参数类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performOperation</span><span class="hljs-params">(T1 x, T1 y, T1 (*operation)(T1, T1))</span> </span>&#123; <span class="hljs-comment">//operation为别名</span><br>    T1 result = <span class="hljs-built_in">operation</span>(x, y);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The result is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 将相加函数作为参数传递给 performOperation 函数</span><br>    <span class="hljs-built_in">performOperation</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, add);<br><br>    <span class="hljs-built_in">performOperation</span>(<span class="hljs-number">3.5</span>, <span class="hljs-number">4.6</span>, add);<br><br>    <span class="hljs-comment">// 将相乘函数作为参数传递给 performOperation 函数</span><br>    <span class="hljs-built_in">performOperation</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, multiply);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h3 id="函数指针的声明和调用">函数指针的声明和调用</h3><p>在C++中，函数指针是指向函数的指针变量。它存储了函数的地址，可以通过函数指针调用相应的函数。</p><p>函数指针的声明和使用方式如下：</p><ol type="1"><li>声明函数指针：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">returnType</span> (*ptrName)(parameterTypes);<br></code></pre></td></tr></table></figure><p>这里的 returnType 是函数的返回类型，parameterTypes是函数的参数列表，ptrName 是函数指针的名称。</p><ol start="2" type="1"><li><p>将函数的地址赋给函数指针： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ptrName = functionName;<br></code></pre></td></tr></table></figure> 这里的 functionName是函数的名称，可以直接将函数名赋给函数指针。</p></li><li><p>通过函数指针调用函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">returnType result = (*ptrName)(arguments);<br></code></pre></td></tr></table></figure> 或者简写为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">returnType result = <span class="hljs-built_in">ptrName</span>(arguments);<br></code></pre></td></tr></table></figure>这里的 arguments 是函数的参数。 举一个实例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//template&lt;class T&gt;</span><br><span class="hljs-comment">//using op = T(*) (T , T );</span><br><span class="hljs-keyword">using</span> Operation = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">double</span> a1 = <span class="hljs-number">11.1</span>, b1 = <span class="hljs-number">12.1</span>;<br>    Operation operation;<br>    operation = add;<br>    cout&lt;&lt;<span class="hljs-built_in">operation</span>(a,b)&lt;&lt;endl;<br>    operation = multiply;<br>    cout&lt;&lt;<span class="hljs-built_in">operation</span>(a,b)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><p>同样的，可以结合函数模板和函数指针，实现类似多态的效果，调用不同返回类型的函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义一个函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T value, <span class="hljs-type">void</span> (*func)(T))</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(value);<br>&#125;<br><br><span class="hljs-comment">// 定义两个不同的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Integer value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDouble</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Double value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用函数模板和函数指针实现多态效果</span><br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">5</span>, &amp;printInt);  <span class="hljs-comment">// 调用 printInt 函数</span><br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">3.14</span>, &amp;printDouble);  <span class="hljs-comment">// 调用 printDouble 函数</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Openfoam学习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openfoam学习记录 - 基本的文件结构</title>
      <link href="/2022/12/03/post03/"/>
      <url>/2022/12/03/post03/</url>
      
        <content type="html"><![CDATA[<h1 id="openfoam学习记录一---基本的文件结构">Openfoam学习记录一 -基本的文件结构</h1><p>从现在开始学习开源软件Openfoam并记录学习的过程。因为Openfoam的内容非常多非常杂，需要及时梳理方便回顾，并上手做一些小案例。我总觉得之前学习CFD不到位一个点就是太重视输入，不重视输出，不重视结果的讨论与分析，这是一个毛病，也是我在写使用Openfoam博客中想加入的东西来帮助自己改正。</p><p>这个学习记录博客素材的主要来源:Wolfdynamics培训资料(http://www.wolfdynamics.com/tutorials.html?layout=edit&amp;id=181)、武汉理工大学博士汪洋的培训课程及其开源的Openfoam入门培训讲义(B站名：大官人学CFD)、红宝书、Openfoam用户指南、以及CFD-ONLINE的论坛内容。因为是入门记录，所以内容上会有一些重合内容，对我来说也相当于是资料的整理和归纳。</p><h2 id="openfoam的文件结构">Openfoam的文件结构</h2><p>使用快捷命令foam可以直接进入主文件夹，在终端中输入tree -L 1可以看到：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Allwmake<br>├── COPYING<br>├── README.md<br>├── README.org<br>├── applications <span class="hljs-comment">#求解器，前后处理工具及其他工具源码</span><br>├── bin <span class="hljs-comment">#常用的脚本</span><br>├── doc <span class="hljs-comment">#Openfoam文档，需要使用Doxygen编译本地文档</span><br>├── etc <span class="hljs-comment">#环境文件夹</span><br>├── platforms<br>├── src<br>├── <span class="hljs-built_in">test</span><br>├── tutorials<br>└── wmake <br></code></pre></td></tr></table></figure>在Openfoam中的bashrc文件中，定义了Openfoam中的基本设置，包括并行核数、编译平台、并行MPI类型等等，另外还可以在$WM_PROJECT_DIR/etc/config.sh/aliases文件中给出了快捷指令的含义。例如foam是进入Openfoam中主文件夹，tut是进入自带案例文件夹。</p><p>常用的三个Linux命令</p><ol type="1"><li><p>grep命令：搜索命令，用来在输入文本的中搜索特定的内容，并输出到终端界面上，支持正则表达式匹配。用法是grep[option] 搜索内容 搜索文件，不同的option代表的含义的不同：-i：忽略字符大小写 -r：递归地搜索所有子目录-w：只匹配整个单词，而不是单词的一部分-v：反转搜索结果，即输出不包含匹配字符串的所有行-c：输出匹配到的行数而非匹配行的内容 grep -i "hello" file1.txt表示忽略大小写，在file1.txt中找到相应包含"hello"</p></li><li><p>find命令：在指定目录下查找文件和目录，使用不同的选项来过滤和限制查找的结果。用法是find[path] [expression]，find . -name"<strong>openfoam</strong>"，表示在当前文件夹下查找文件名中包含openfoam的文件，find/path/to/search -mtime -7找出7天内修改的文件，find /path/to/search-maxdepth 2 -name "*.txt"这个命令会在路径 /path/to/search及其子目录中查找扩展名为 .txt的文件，但只会搜索到第二层子目录，不会进一步递归下去。</p></li><li><p>awk命令：awk命令是一种经典的文本处理工具，主要用于在 Unix/Linux环境下对文本文件进行数据提取和格式化。可以接受一个或多个文件作为输入，然后按照给定的规则对每行数据进行处理，并输出结果到标准输出或指定的文件。用法awk'pattern { action }' filename。awk -F ',' '$2&gt;30 { print }'data.csv，输出 data.csv 文件中第二列大于30的行。</p></li></ol><h3 id="aplications文件夹">Aplications文件夹</h3><p>OpenFOAM的application文件夹存储了OpenFOAM中可执行程序的源代码和相关文件，主要是C++源代码和Makefile文件，并且使用OpenFOAM库进行编译。App文件内的内容非常重要，在该文件内做的修改会应用到Openfoam全局，所以需要用户自己建立专属于用户自己的App文件夹。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Allwmake<br>├── solvers <span class="hljs-comment">#各类求解器的源代码，以下是按照用途进行分类的源码</span><br>│   ├── DNS          <span class="hljs-comment">#直接数值模拟求解器</span><br>│   ├── acoustic<br>│   ├── basic        <br>│   ├── combustion   <span class="hljs-comment">#燃烧反应求解器</span><br>│   ├── compressible <span class="hljs-comment">#可压缩求解器</span><br>│   ├── discreteMethods<br>│   ├── doc <span class="hljs-comment">#文档</span><br>│   ├── electromagnetics<br>│   ├── financial<br>│   ├── finiteArea<br>│   ├── heatTransfer<br>│   ├── incompressible<br>│   ├── lagrangian<br>│   ├── multiphase <span class="hljs-comment">#多相流求解器</span><br>│   └── stressAnalysis<br>├── <span class="hljs-built_in">test</span>  <span class="hljs-comment">#测试文件夹</span><br>│   ├── 00-dummy<br>│   ├── 00-machine-sizes<br>│   ├── BinSum<br>│   ├── CircularBuffer<br>│   ├── Circulator<br>│   ├── CompactIOList<br>│   ├── DynamicList<br>│   ├── DynamicList2<br>│   ├── Enum<br>        ......<br>│<br>├── tools <span class="hljs-comment">#常用工具源码</span><br>│   ├── README.md<br>│   ├── foamCalc<br>│   └── foamExprParserInfo<br>└── utilities <span class="hljs-comment">#含了一些实用工具，用于处理网格、后处理、转换和可视化数据等任务。</span><br>    ├── doc<br>    ├── finiteArea<br>    ├── mesh<br>    ├── miscellaneous<br>    ├── parallelProcessing<br>    ├── postProcessing<br>    ├── preProcessing<br>    ├── surface<br>    └── thermophysical<br></code></pre></td></tr></table></figure></p><h3 id="bin文件夹">bin文件夹</h3><p>bin文件夹中包含了许多实用的shell脚本，每个脚本在激活Openfoam环境时，可以直接当做命令使用。例如foamCleanTutorials脚本，可以将所有的计算结果全部清空。paraFoam脚本可以直接启动paraview进行后处理。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── foamCheckJobs<br>├── foamCleanPath<br>├── foamCleanPolyMesh <span class="hljs-comment">#清除网格</span><br>├── foamCleanTutorials <span class="hljs-comment">#清除计算结果</span><br>├── foamCloneCase<br>├── foamCopySettings<br>├── foamCreateVideo<br>├── foamEndJob<br>├── foamEtcFile<br>├── foamGetDict<br>├── foamInstallationTest<br>├── foamJob<br>├── foamLog<br>├── foamMonitor<br>├── foamNew<br>├── foamNewApp <span class="hljs-comment">#创建自己app</span><br>├── foamNewBC <br>├── foamNewCase<br>├── foamNewFunctionObject<br>├── foamNewSource -&gt; ../etc/codeTemplates/source/foamNewSource<br>├── foamNewTemplate -&gt; ../etc/codeTemplates/template/foamNewTemplate<br>├── foamPrintJobs<br>├── foamRunTutorials<br>├── foamSearch<br>├── foamSequenceVTKFiles<br>├── foamSolverSweeps<br>├── foamSystemCheck<br>├── foamTestTutorial<br>├── mpirunDebug<br>├── paraFoam <span class="hljs-comment">#启动paraview后处理</span><br>└── tools<br>    ├── CleanFunctions<br>    ├── LogFunctions<br>    ├── MakefileDirs<br>    ├── README<br>       ......<br>    ├── doxyFilter.sed<br>    ├── findEmptyMake<br>    ├── foamConfigurePaths<br>    ├── foamCreateCompletionCache<br>    ├── foamCreateManpage<br>    ├── foamCreateModuleInclude<br>    ├── foamExec<br>    ├── foamGrepExeTargets<br>    ├── foamLog.db<br>    ├── foamPackRelease<br>    ├── foamUpdateCaseFileHeader<br>    ├── git-find-non-ascii<br>    ├── git-find-trailingspace<br>    ├── help-filter<br>    ├── install-dirs<br>    ├── install-platform<br>    ├── lib-dir<br>    ├── openfoam.in<br>    ├── pre-commit-hook<br>    ├── pre-receive-hook<br>    ├── query-detect<br>    ├── query-versions<br>    ├── source-bashrc<br>    ├── update-mpi-links.in<br>    └── vscode-settings<br></code></pre></td></tr></table></figure></p><h3 id="etc文件夹">etc文件夹</h3><p>etc文件夹中包含了许多环境配置文件，包括bashrc、各类模板、以及热物性库等等文件。其中caseDicts中，有许多输入文件的模板。对于自己编写自定义的文件有比较多的参考意义。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── bashrc<br>├── bashrc-e<br>├── caseDicts<br>├── cellModels<br>├── codeTemplates<br>├── colourTables<br>├── config.csh<br>├── config.sh<br>├── controlDict <br>├── cshrc<br>├── cshrc-e<br>├── openfoam<br>├── prefs.csh<br>├── prefs.sh<br>├── templates<br>└── thermoData<br></code></pre></td></tr></table></figure></p><h3 id="src文件夹">src文件夹</h3><p>src文件夹中包含了Openfoam最核心、最底层的源代码，其中包括求解器、网格生成器、库函数、物理模型等等。通常情况下，这些源代码需要进行修改，以便用户创建自己的定制应用程序。用户可以通过修改文本文件、头文件或使用C++等编程语言来实现自定义功能。app文件夹中的内容旨在解决流体动力学领域的各种问题。包括求解器和辅助工具，如网格生成器和后处理工具等。这些应用程序大多数都是不需要修改的，用户可以通过控制参数文件（system文件夹中）来设置运行选项。简单地说，src文件夹中的内容更为底层，是app文件夹中内容的基础。</p><p>对比src文件和app文件中的差异就是， <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── Allwmake<br>├── Allwmake-scan<br>├── ODE<br>├── OSspecific<br>├── OpenFOAM<br>├── Pstream<br>├── TurbulenceModels<br>├── atmosphericModels<br>├── combustionModels<br>├── conversion<br>├── dummyThirdParty<br>├── dynamicFaMesh<br>├── dynamicFvMesh<br>├── dynamicMesh<br>├── engine<br>├── faOptions<br>├── fileFormats <br>├── finiteArea<br>├── finiteVolume  <span class="hljs-comment">#提供有限体积法离散所需要的底层支持，网格离散、标量、矢量运算等等</span><br>├── functionObjects<br>├── fvAgglomerationMethods<br>├── fvMotionSolver<br>├── fvOptions<br>├── genericPatchFields<br>├── lagrangian<br>├── lumpedPointMotion<br>├── mesh<br>├── meshTools<br>├── optimisation<br>├── overset<br>├── parallel<br>├── phaseSystemModels<br>├── randomProcesses<br>├── regionFaModels<br>├── regionModels<br>├── renumber<br>├── rigidBodyDynamics<br>├── rigidBodyMeshMotion<br>├── sampling<br>├── sixDoFRigidBodyMotion<br>├── sixDoFRigidBodyState<br>├── surfMesh<br>├── thermoTools<br>├── thermophysicalModels<br>├── topoChangerFvMesh<br>├── transportModels<br>└── waveModels<br></code></pre></td></tr></table></figure></p><h3 id="platforms文件夹">platforms文件夹</h3><p>在编译appOpenfoam源代码和应用程序所生成的二进制文件和库文件都存放在该文件夹中。该文件夹内容十分重要，保存了开发程序所需要的所有库文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">. <br>├── linux64GccDPInt32Opt<br>│   ├── applications<br>│   ├── bin <span class="hljs-comment">#编译过程中所生成的二进制文件</span><br>│   ├── lib <span class="hljs-comment">#编译过程中所生成的库文件.so文件</span><br>│   └── src<br>└── linux64GccDPInt32OptSYSTEMOPENMPI<br>    └── src <span class="hljs-comment">#编译所需要的所有源文件，与src文件夹和app文件夹内容对应，但是其中是.o文件和.C.dep文件</span><br></code></pre></td></tr></table></figure></p><h2 id="小结">小结</h2><p>认识Openfoam的文件结构对我来说最大的帮助是理解一个大型项目构建的基本逻辑，怎么样去设计框架，例如openfoam将有关网格、前后处理、离散、基础模型放在src中，再将基于这些内容所开发的求解器放在app中，实现分离，将项目构建清晰。然后就是，在日常使用中，哪里出现问题了，可以对照去相应的文件夹找到参考内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Openfoam学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔：在超算-计算集群中编译安装OpenFOAM-5.x</title>
      <link href="/2022/11/30/blog02/"/>
      <url>/2022/11/30/blog02/</url>
      
        <content type="html"><![CDATA[<h1 id="安装的准备">安装的准备</h1><p>现在OpenFOAM已经更新到了第十版，之所以安装5版本，是因为我个人现在做CFD-DEM耦合的工作，CFDEM耦合软件支持的OpenFOAM就是5.x版本。不管是哪一个版本，安装过程和准备文件是基本一致的。安装过程主要参考如下博客和帖子： <a href="https://www.cfd-china.com/topic/4296/">https://www.cfd-china.com/topic/4296/</a>一种集群非root用户编译openfoam的方法-基于centos7<a href="https://blog.csdn.net/weixin_41734903/article/details/105125214">https://blog.csdn.net/weixin_41734903/article/details/105125214</a><a href="https://blog.csdn.net/weixin_42230462/article/details/115555172">https://blog.csdn.net/weixin_42230462/article/details/115555172</a></p><h2 id="文件清单">文件清单</h2><p>采用编译安装方式，首要就是准备好OpenFOAM的源代码，这个通过gitclone或者下载官网上的源码压缩包就可以了。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://github.com/OpenFOAM/OpenFOAM-5.x.git<br>git <span class="hljs-built_in">clone</span> git://github.com/OpenFOAM/ThirdParty-5.x.git<br></code></pre></td></tr></table></figure>由于在计算集群（超算）中，个人用户是没有安装底层库的权限的，且集群不连接外网，需要用户自己将一些必要的库准备好，然后传上去。超算平台和大型计算平台主要采用CentOS7系统，接下来的操作都以该系统为例。如果自己不清楚自己的系统版本，可以用uname-a命令查看系统版本，lsb_release -a可以查看属于什么操作系统。首先需要在自己的个人电脑上面安装一个与集群上系统一致的本地Linux虚拟机，个人可以使用VMwareworkstation play免费创建虚拟机。虚拟机的安装过程比较简单，不再赘述。在本地虚拟上，首先换源，换成国内源，下载软件速度快。然后安装yum-utils包，用来下载必须的依赖库。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su root <span class="hljs-comment">#在本地虚拟机上输入密码，切换成为root用户</span><br>yum -y install yum-utils<br></code></pre></td></tr></table></figure>然后下载OpenFOAM的依赖库，比较关键的有：binutils、boost、bison、flex、glibc、hwloc、m4、libtool、zlib，cmake这几个库的安装方式一致，以binutils为例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/<br><span class="hljs-built_in">mkdir</span> packages <span class="hljs-comment">#建立一个文件夹统一存放这些库</span><br><span class="hljs-built_in">cd</span> packages &amp;&amp; <span class="hljs-built_in">mkdir</span> binutils <span class="hljs-comment">#在packages下面建立一个文件夹存放binutils库</span><br>yumdownloader binutils <span class="hljs-comment">#下载这个库的软件包</span><br><span class="hljs-comment">#如果所有的库都按照这个顺序下载好了，可以先打包上传到集群中</span><br><span class="hljs-comment">#接下来就是解压库，然后将路径加入到bashrc，这里还是先在本地虚拟机操作，成功安装这些库，然后再在超算上实现一次</span><br><span class="hljs-built_in">cd</span> binutils<br>rpm2cpio binutils-2.27-44.base.el7_9.1.x86_64.rpm | cpio -idvm <span class="hljs-comment">#解压包，然后可以在binutils文件夹下面发现多出一个usr文件夹</span><br>vim ~/.bashrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/packages/binutils/usr/bin <span class="hljs-comment">#将库文件目录加入到系统目录中，至此，这个库已经装好了</span><br><br><span class="hljs-comment">#重复以上步骤，依次安装所有的库，现在本地安装通过，再在超算上重复操作。保持两者一致性。</span><br></code></pre></td></tr></table></figure>这里有一个值得一说的点，由于CentOS7默认的gcc版本是4.85，刚好符号OpenFOAM-5.x安装要求，我并没有再安装gcc，gcc版本太旧或者太新都会导致编译出错。然后是安装openmpi，从安装角度，这个是OpenFOAM最推荐使用的并行库，且集群中，最好只有这个并行库，mpich可能会和openmpi起冲突。如果使用intelmpi，会在AMD核心集群上存在兼容性问题。如果集群中安装了别的并行库，最好先卸载掉。检查OpenFOAM-5.x使用的是openmpi2.1版本，从Openmpi官网上下载源码，在本地和集群中都保留一份。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/<br><span class="hljs-built_in">mkdir</span> openmpi <span class="hljs-comment">#建立openmpi的安装路径</span><br><span class="hljs-built_in">cd</span> OpenFOAM<br><span class="hljs-built_in">cd</span> Third-party-5.x/ <span class="hljs-comment">#最好将openmpi源码解压到此文件夹下，因为可能会有一些找不到文件的错误</span><br>tar -zxvf openmpi-2.1.1.tar.gz <span class="hljs-comment">#解压openmpi的源码</span><br><span class="hljs-built_in">cd</span> openmpi-2.1.1/<br>./configure --prefix=/home/username/openmpi/ <span class="hljs-comment">#配置openmpi</span><br>make &amp;&amp; make install <span class="hljs-comment">#耐心等待安装完成</span><br></code></pre></td></tr></table></figure> username是自己的账户名，不是就打一个"username"就可以了如果在openmpi编译过程中，出现了“****-l和-lr之间没有空格”这个编译错误，是openmpi的一个bug，将配置语句改成<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/home/username/openmpi --with-ucx=/usr<br></code></pre></td></tr></table></figure>就可以正常编译，然后没有错误以后，将openmpi的路径加入到系统路径中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/openmpi/bin<br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/home/username/openmpi/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br><span class="hljs-built_in">source</span> ~/.bashrc <span class="hljs-comment">#让配置文件生效</span><br></code></pre></td></tr></table></figure> 如果没有报错，可以运行一下mpicc或者whichmpicc，如果没有出现mpicc notfound这样的错误，并且显示了mpicc的路径就是安装成功了。</p><h1 id="编译openfoam-5.x">编译OpenFOAM-5.x</h1><p>到这里，我个人建议，是本地虚拟机和计算集群都执行一样的操作，保持一致性。这样也方便以后自己程序的调试，至于还有一个作用，在文末可以看到。首先，需要将OpenFOAM的环境说明写入系统.bashrc文件里面： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> <span class="hljs-variable">$HOME</span>/OpenFOAM/OpenFOAM-5.x/etc/bashrc WM_LABEL_SIZE=64 WM_COMPILER_TYPE=system WM_COMPILER=Gcc WM_MPLIB=OPENMPI <br></code></pre></td></tr></table></figure>如果没有报错，说明可以正式编译OpenFOAM了，先进入到Third-party下面：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./Allclean<br>./Allwmake -j4<br><span class="hljs-comment">#如果在集群上，可以用更多核心编译，速度会变快 srun -c64 ./Allwmake -j64</span><br></code></pre></td></tr></table></figure> 如果编译顺利通过，可以编译OpenFOAM: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/OpenFOAM/OpenFOAM-5.x<br>./Allwmake -j4 <span class="hljs-comment">#耗时数小时</span><br><span class="hljs-comment">#同理如果在集群上，可以用更多核心编译，速度会变快 srun -c64 ./Allwmake -j64</span><br></code></pre></td></tr></table></figure>如果没有报错，可以执行一下blockMesh，如果看到出现OpenFOAM的标志，就是安装成功了<img src="https://cdn.nlark.com/yuque/0/2022/png/34567141/1669996035908-f8cdf2e6-bd70-412c-9b9c-6f5b489cc556.png#averageHue=%23fcfcfc&amp;clientId=u417a18bd-49e7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=346&amp;id=u284e3e3e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=914&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=150713&amp;status=done&amp;style=none&amp;taskId=u75ff3184-01f4-48ed-a678-871b005d833&amp;title=&amp;width=914" alt="image.png"></p><h1 id="可能遇到的错误">可能遇到的错误</h1><p>目前我遇到的错误，绝大多数情况都是找不到mpi.h，这个是由于openmpi没有配置好。如果按照文中的步骤，最后能看到mpi的环境成功配置应该就没有问题。其次，找不到****.h或者***.c大部分是因为缺少依赖库。例如我一开始在本地虚拟机安装了glibc，libtool库，但是集群中没有，编译一直不过，这个时候建议首先检查依赖库。最后一个，如果Third-party能够成功编译，基本上OpenFOAM也能顺利编译，如果最后实在是编译不过，也找不到原因。可以将本地编译好的Thirdparty打包上传到集群再解压，然后再重新编译，这也是为什么要保持本地虚拟机和集群，操作系统以及安装操作一致性的原因。因为本地虚拟机，权限和上网可控，但是集群都不行，本地的编译出现问题较容易解决。最后看一下我自己的.bashrc文件 <img src="https://cdn.nlark.com/yuque/0/2022/png/34567141/1669996433706-a2323a2a-3a2f-4a42-aac0-f72f887a5100.png#averageHue=%23f6f9e9&amp;clientId=u417a18bd-49e7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u51a4108e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=235&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=161333&amp;status=done&amp;style=none&amp;taskId=u101bf169-95f6-4f9e-8754-ba3cd834169&amp;title=&amp;width=480" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 偏微分方程数值解 </tag>
            
            <tag> CFD </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOOSE多物理场耦合平台入门学习记录（二）- 牛顿法求解非线性方程组</title>
      <link href="/2022/07/05/blog01/"/>
      <url>/2022/07/05/blog01/</url>
      
        <content type="html"><![CDATA[<p>放在首页的话：本人撰写博客最主要的目的是整理自己对研究对象的认识，积累经验，加深理解。自身水平并不高，很多都是靠自学。如果有大佬看出其中的错误或者有新的角度理解，还请留言指点，非常感谢，这对于我水平提高有很大的帮助。</p><h1 id="牛顿法的简介">牛顿法的简介</h1><p>NEWTONSolver是MOOSE平台三大求解器之一（NEWTON、JFNK、PJFNK），简要了解牛顿法的基本原理对于理解MOOSE平台的底层机制有一定帮助，也能帮助判断使用NEWTONsolver收敛失败的原因。本博文主要参考这篇文章(https://zhuanlan.zhihu.com/p/139595720)，以及一个非常简洁明了的教学视频(https://www.bilibili.com/video/BV19Q4y1S7dR?spm_id_from=333.337.search-card.all.click&amp;vd_source=b154dc71d458a24aaa3478de44369f37)。</p><h2 id="牛顿法求解非线性方程">牛顿法求解非线性方程</h2><p>大多数数值分析的教科书都是首先介绍牛顿法求解非线性方程。牛顿法的基本思想来自于泰勒公式，假设现存一个非线性方程<span class="math inline">\(y = f(x) =b\)</span>，首先将方程转化为求根问题，即<span class="math inline">\(F(x)= f(x)-b=0\)</span>。在某一点<span class="math inline">\(x_0\)</span>处，进行泰勒展开，可以得到： <span class="math display">\[F(x) = F(x_0) + F^{&#39;}(x - x_0) + \frac{F^{&#39;&#39;}(x_0)}{2}(x -x_0)^2 + O(\Delta x) \tag{1}\]</span> 对于线性方程，仅取一阶近似就可以满足要求，可以得到: <span class="math display">\[\begin{array}{c}    F(x_0) + F^{&#39;}(x - x_0) = 0 \\    x = x_0 - \frac{F(x_0)}{F^{&#39;}(x_0)}\end{array} \tag{2}\]</span> 显然此时的<span class="math inline">\(x\)</span>并不可能直接就是方程的根，但是可以重复迭代，使得<span class="math inline">\(x\)</span>不断逼近方程根，直到满足要求。从图像上看，其过程就是，在一个方程所表达的曲线上选取一个点<span class="math inline">\(x_0\)</span>，然后在该点做与曲线的切线，切线与x轴相交的点，其坐标值就是下一步迭代的<span class="math inline">\(x_1\)</span>，然后再<span class="math inline">\(x_1\)</span>所对应曲线上的点，继续做切线，切线与x轴相交的点<span class="math inline">\(x_3\)</span>，反复重复上述过程，直到<span class="math inline">\(x_n\)</span>达到预设误差的要求。</p><p>但是，对于需要求解函数的极值问题，取一阶近似就不能满足要求了，需要将其转化为求解其导数为0问题，再使用牛顿法，因此，常见求解非线性方程选取的是二阶近似：<span class="math display">\[\begin{array}{c}    F(x) = F(x_0) + F^{&#39;}(x - x_0) + \frac{F^{&#39;&#39;}(x_0)}{2}(x- x_0)^2 = 0\end{array} \tag{3}\]</span> 对上式，左右再进行求导可以得到: <span class="math display">\[\begin{array}{c}    F^{&#39;}(x_0) + F^{&#39;&#39;}(x - x_0) = 0 \\    x = x_0 - \frac{F^{&#39;}(x_0)}{F^{&#39;&#39;}(x_0)}\end{array} \tag{4}\]</span>可以看到，牛顿法使用的前提，是曲线导数存在，而在实际使用中，求导数是一个非常难处理的问题，可以使用差分来近似。</p><h2 id="牛顿法求解非线性方程的编程实现">牛顿法求解非线性方程的编程实现</h2><p>以方程<span class="math inline">\(x^2 - 2x -3 =0,x&gt;0\)</span>为例，其一阶导数和二阶导数分别是<span class="math inline">\(2x-2, 2\)</span>，代码如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x*x - <span class="hljs-number">2</span>*x - <span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">firstOD</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#一阶导数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x - <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">secondOD</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#二阶导数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-comment"># 以下为一阶近似牛顿法</span><br>x0 = <span class="hljs-number">0.0</span> <span class="hljs-comment">#初始值</span><br>err_limit = <span class="hljs-number">1e-10</span> <span class="hljs-comment">#误差限</span><br>err_iter = <span class="hljs-number">1.0</span><br>iter_num = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span>(err_iter &gt; err_limit):<br>    xn = x0 - F(x0)/firstOD(x0)<br>    err_iter = <span class="hljs-built_in">abs</span>(xn - x0)<br>    x0 = xn<br>    iter_num = iter_num + <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The iter num for Newton method 1st is &#x27;</span> + <span class="hljs-built_in">str</span>(iter_num))<br></code></pre></td></tr></table></figure></p><p>示例方程确实太简单了，也可以看到，单纯使用牛顿法编程并不复杂（前提是导数易求解和易计算），还有就是初值的影响非常大，第一个是初值选取不当，容易陷入初值陷阱，计算失败。第二个就是可能迭代不到想要的解，如上面的方程，应该有两个根，如果初值选取小于1.0，则是求解的-1的根，但是实际想要的是<span class="math inline">\(x&gt;0\)</span>的解。因为牛顿法单次只能搜寻某个局部区间的解。因此在使用牛顿法前，对方程的几何特性最好要有一定把握。</p><h2 id="牛顿法求解非线性方程组">牛顿法求解非线性方程组</h2><p>如果是方程组，那么解就不是一个单个的数，而是一个解向量<span class="math inline">\([x_0,x_1,x_2,\cdots,x_n]\)</span>，对应方程组为:<span class="math display">\[\begin{bmatrix}    f_{1}(x_0,x_1,x_2,\cdots,x_n)  \\    f_{2}(x_0,x_1,x_2,\cdots,x_n) \\    f_{3}(x_0,x_1,x_2,\cdots,x_n) \\      \vdots \\    f_{n}(x_0,x_1,x_2,\cdots,x_n)\end{bmatrix} =\begin{bmatrix}    0 \\    0 \\    0 \\    \vdots \\    0\end{bmatrix} \tag{5}\]</span>对左侧矩阵中的每一项使用多元泰勒展开，与前述过程类似，取一阶梯度，写成迭代格式，可以得到：<span class="math display">\[\begin{array}{c}    F(X^{k}) + \nabla F(X^{k})(X^{k+1} - X^{k}) = 0 \\    (X^{k+1} - X^{k}) =  - \nabla F(X^{k})^{-1}F(X^{k})\end{array} \tag{6}\]</span> 上式中，<span class="math inline">\(\nabla F(X^{k})\)</span>就是常见的Jacbobian矩阵，注意，上式中，已经不是简单的乘除法，而是涉及到矩阵求逆运算，并不满足交换律。X也是一个解向量，而不是一个单个数值。Jacbobian矩阵的形式如下：<span class="math display">\[\begin{bmatrix}    \frac{\partial f_1}{\partial x_0} &amp; \frac{\partial f_1}{\partialx_1} &amp; \cdots &amp;  \frac{\partial f_1}{\partial x_n} \\    \frac{\partial f_2}{\partial x_0} &amp; \frac{\partial f_2}{\partialx_1} &amp; \cdots  &amp; \frac{\partial f_2}{\partial x_n} \\    \vdots&amp;\vdots&amp; \ddots &amp; \vdots \\    \frac{\partial f_n}{\partial x_0} &amp; \frac{\partial f_n}{\partialx_1} &amp; \cdots  &amp;\frac{\partial f_n}{\partial x_n}\end{bmatrix}\]</span></p><h2 id="牛顿法求解非线性方程组的编程实现">牛顿法求解非线性方程组的编程实现</h2><p>以如下方程为示例，其几何意义就是一直线与圆相交的两点。这里仅考虑y&gt;0的解：<span class="math display">\[\begin{cases}    x^2 + y^2 = 16 \\    y -\sqrt{3}x = 0\end{cases} \tag{7}\]</span> 待求解方程和Jacobian矩阵如下： <span class="math display">\[\begin{cases}    x^2 + y^2 -16 = 0 \\    -\sqrt{3}x + y -4 =0\end{cases},\begin{bmatrix}    2x &amp; 2y \\    -\sqrt{3} &amp; 1\end{bmatrix}\]</span> 代入6式中的迭代表达式： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#以下为牛顿法求解方程组程序</span><br>    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f11</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#四个偏导数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f12</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f21</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>*sqrt(<span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f22</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">err_cal</span>(<span class="hljs-params">a,b</span>): <span class="hljs-comment">#计算误差，不同的误差统计方法函数不同，这里采用平方和</span><br>        n = np.size(a,axis=<span class="hljs-number">0</span>)<br>        err_sum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            err_sum = err_sum + (a[i] - b[i])**<span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> sqrt(err_sum)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Jacobian_cal</span>(<span class="hljs-params">x</span>):<br>        n = np.size(x,axis=<span class="hljs-number">0</span>)<br>        tempm = np.zeros([n,n])<br>        tempm[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = f11(x)<br>        tempm[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = f12(x)<br>        tempm[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = f21(x)<br>        tempm[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = f22(x)<br>        <span class="hljs-keyword">return</span> tempm<br>    err_limit = <span class="hljs-number">1e-5</span><br>    err_iter = <span class="hljs-number">1</span><br>    xi = np.zeros([<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])<br>    xi[<span class="hljs-number">0</span>] = <span class="hljs-number">3.0</span><br>    xi[<span class="hljs-number">1</span>] = <span class="hljs-number">2.0</span><br>    JM = np.zeros([<span class="hljs-number">4</span>,<span class="hljs-number">4</span>])<br>    iter_num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(err_iter &gt; err_limit):<br>        JM = Jacobian_cal(xi)<br>        xi_old = xi.copy()<br>        F = np.zeros([<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])<br>        F[<span class="hljs-number">0</span>] = xi[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> + xi[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span> - <span class="hljs-number">16</span><br>        F[<span class="hljs-number">1</span>] = -sqrt(<span class="hljs-number">3</span>)*xi[<span class="hljs-number">0</span>] + xi[<span class="hljs-number">1</span>]<span class="hljs-comment">#计算F(x^k)</span><br>        <span class="hljs-built_in">print</span>(F)<br>        tempjms = np.linalg.inv(JM) <span class="hljs-comment">#对Jacobian矩阵求逆</span><br>        Rn = -<span class="hljs-number">1</span>*tempjms.dot(F)<br>        xi = xi + Rn <span class="hljs-comment">#计算xi+1，作为下一步迭代初始值</span><br>        err_iter = err_cal(xi_old,xi) <span class="hljs-comment">#计算迭代误差</span><br>        iter_num = iter_num + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(xi)  <span class="hljs-comment">#输出结果</span><br>    <span class="hljs-built_in">print</span>(iter_num)<br></code></pre></td></tr></table></figure>在牛顿法中，Jacobian矩阵的性质决定了迭代的结果好坏，有可能会出现如下情况：</p><ol type="1"><li>Jacobian矩阵迭代过程中产生奇异，不可以再求逆，迭代就会失败。</li><li>由于求解导数，以及矩阵求逆本身就是很复杂的运算，需要耗费大量计算资源，很容易出现错误，这与方程本身的特性相关。例如，上面方程如果x和y的系数互为相反数，则难以迭代出正确解。</li><li>初值选取不当，造成了后面一系列迭代计算的恶化。</li></ol><p>如果准确求解Jacobian矩阵并且保持迭代过程中矩阵有良好的计算特性是应用牛顿法的大问题。同时也可以看到，牛顿法求解方程组是所有方程同步求解的，并不是类似Picard迭代一样，完成一个场的计算再代入另一个场计算，有利于考虑不同物理场方程之间的高度非线性耦合关系，但是计算要求也更高。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 偏微分方程数值解 </tag>
            
            <tag> 有限差分法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
