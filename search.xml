<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenFOAM基础 - c++ note1</title>
      <link href="/2023/11/01/post04/"/>
      <url>/2023/11/01/post04/</url>
      
        <content type="html"><![CDATA[<h1 id="c20的学习----碎碎念01">c++20的学习 -- 碎碎念01</h1><p>这篇文章并不是深入学习C++的总结，只是为了记录在学习C++过程中的练习和代码，熟悉C++20的一些新特性与编程方法。对于C++而言，最重要的是设计模式，类的构思，将大型项目化整为零的能力。</p><h2 id="静态链接库和动态链接库">静态链接库和动态链接库</h2><p>静态链接库和动态链接库都是C++函数的具体实现，一般要配合相应的库头文件使用。这种做法维护了函数的具体实现不被外界获知，也使开发者不用去纠结函数的具体实现而是专注在上层结构的开发中，便于使程序整体清晰、解耦。但是静态链接库和动态链接库在使用方法上还是有很大区别：</p><ul><li>静态链接库在编译时被链接到程序中，因此也被称为静态库。当程序被编译链接时，静态链接库的代码会被全部复制到生成的可执行文件中。优点是程序的运行不依赖于外部的库文件，可以在没有额外依赖的情况下在不同的环境中运行。缺点：每个使用该静态库的程序都会包含一份静态库的副本，导致可执行文件的大小增加，并且占用更多的内存空间。</li><li>动态链接库在程序运行时被加载到内存中，因此也被称为共享库。程序在运行时会动态地链接到动态链接库中的函数和资源。优点是减小了可执行文件的大小，节约了内存空间，而且如果多个程序使用同一个动态链接库，那么系统只需要加载一份该库的副本，节约了系统资源。缺点是程序的运行依赖于外部的库文件，如果某个动态链接库被删除或损坏，那么依赖于它的程序将无法正常运行。</li></ul><h3 id="如何在mac中使用库文件来构建程序">如何在Mac中使用库文件来构建程序</h3><p>首先给出一个基本的程序，这个程序是调用了外部的函数，所以需要将外部函数生成链接库的形式：</p><p>hello.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;add.hpp&quot;</span> <span class="hljs-comment">//外部函数头文件</span></span><br></code></pre></td></tr></table></figure><p>hello.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;hello.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(a,b)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>外部函数add.hpp头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>外部函数add.cpp头文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;add.hpp&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先使用clang++将外部函数编译成函数链接库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang++ -std=c++20 -shared -o libadd.dylib add.cpp<br></code></pre></td></tr></table></figure><p>其中，-shared指令表示生成共享链接库，就是动态链接库，如果是静态链接库，就是-static，然后就是编译过程中引用外部链接库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang++ -std=c++20 -I ./ hello.cpp -L./ -ladd -o hello<br></code></pre></td></tr></table></figure><p>注意，这其中-I、-L、-l的作用有差异，作用如下（chatgpt）：</p><p>在使用 g++编译器时，可以通过不同的选项来指定库文件和头文件的位置，其中<code>-L</code>、<code>-l</code> 和 <code>-I</code>是常用的选项，它们分别表示如下意思：</p><ol type="1"><li><code>-L</code> 选项：<ul><li><code>-L</code>选项用于指定库文件的搜索路径，告诉编译器在哪里寻找要链接的库文件。</li><li>例如，如果你的库文件位于 <code>/path/to/lib</code>目录下，你可以使用 <code>-L/path/to/lib</code>来告诉编译器在该目录下寻找库文件。</li></ul></li><li><code>-l</code> 选项：<ul><li><code>-l</code> 选项用于指定要链接的库文件的名称，通常是去掉开头的<code>lib</code> 前缀和文件扩展名的部分。</li><li>例如，如果你要链接的库文件为 <code>libexample.a</code> 或<code>libexample.so</code>，你可以使用 <code>-lexample</code>来告诉编译器链接这个库文件。</li></ul></li><li><code>-I</code> 选项：<ul><li><code>-I</code>选项用于指定头文件的搜索路径，告诉编译器在哪里寻找包含文件（头文件）。</li><li>例如，如果你的头文件位于 <code>/path/to/include</code>目录下，你可以使用 <code>-I/path/to/include</code>来告诉编译器在该目录下寻找头文件。</li></ul></li></ol><p>综上所述，<code>-L</code> 用于指定库文件的搜索路径，<code>-l</code>用于指定要链接的库文件的名称，而 <code>-I</code>用于指定头文件的搜索路径。这些选项可以帮助编译器正确地找到并链接需要的库文件和头文件，从而顺利完成程序的编译过程。</p><h2 id="函数重载">函数重载</h2><p>函数重载是重要内容，在C++中应用广泛。声明一个函数需要返回值类型 +函数名 +参数列表，由于C++中每一个变量都必须说明变量的类型，是浮点型、整数型还是字符类型等。所以对应不同的输入参数，如果函数要实现的功能又一致的话，就需要进行函数重载。函数重载有三条限制：</p><ul><li>被重载的函数具有相同的函数名</li><li>参数列表不同：被重载的函数必须具有不同的参数列表。参数列表可以通过参数的类型、参数的顺序或参数的个数来区分。</li><li>返回类型不同不足以进行重载：函数的返回类型不会被视为函数重载的一部分。如果两个函数具有相同的参数列表，但是返回类型不同，将无法进行重载。</li></ul><p>以下为具体实例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-comment">// void add(int a, int b) 不构成函数重载</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//     int c = a+b;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-type">double</span> a1,b1;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cin&gt;&gt;a1&gt;&gt;b1;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(a,b)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(a1,b1)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 程序的输入与输出： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">in</span>:<br>10 10<br>98.5 1.5<br>out:<br>20<br>100<br></code></pre></td></tr></table></figure></p><h2 id="函数模板">函数模板</h2><p>如果每一个不同类型的输入，就要反复重载函数的话，也确实太过于繁琐，因此，采用函数模板可以简化程序，避免大量冗余的代码。通过模板，C++可以根据输入值的类型来反推函数参数的类型，然后将这个函数实例化，变成可以实用的函数。引入模板就已经开始初步涉入泛型编程了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">maximum</span><span class="hljs-params">(T a,T b,T c)</span></span><br><span class="hljs-function"></span>&#123;<br>    T temp=a;<br>    <span class="hljs-keyword">if</span>(a&lt;b)<br>        temp = b;<br>    <span class="hljs-keyword">if</span>(temp&lt;c)<br>        temp = c;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt; <span class="hljs-comment">//多个参数类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T1 a, T2 b)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;  &quot;</span>&lt;&lt;b&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>,b=<span class="hljs-number">11</span>,c=<span class="hljs-number">12</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">maximum</span>(a,b,c)&lt;&lt;endl;<br>    <span class="hljs-type">double</span> a1 = <span class="hljs-number">10.1</span>, b1 = <span class="hljs-number">11.1</span>, c1 = <span class="hljs-number">12.1</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">maximum</span>(a1,b1,c1)&lt;&lt;endl;<br><br>    <span class="hljs-type">int</span> c2  = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">double</span> c3 = <span class="hljs-number">10.1</span>;<br>    <span class="hljs-built_in">print</span>(c2,c3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="数组">数组</h2><p>在c语言中，数组实质是指针，开辟一片连续的内存空间，都需要预先申请内存。C++中，可以使用一些新玩法，新的数据结构。一个是array，一个是vector。其中array是固定数组，类似于在c语言中看到的数组，使用需要引用头文件array。vector是可变向量，使用需要引用头文件vector。无论是array还是vector都是类模板，需要在指定类型后，才能成为一个实际的类。数组的使用，无非是声明，遍历，赋值及修改值，查找和排序。首先以array为例：### 数组的声明及初始化/赋值 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array&lt;<span class="hljs-type">int</span>,5&gt; a; <span class="hljs-comment">//输入int表示这是一个整数类型指针，5表示有5个元素</span><br>    array b&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//同样，对于简单数据类型，也可以直接声明，让array去猜去判断数据类型到底是什么</span><br>    <span class="hljs-comment">//接下来是循环遍历</span><br>    <span class="hljs-comment">//第一种方案，类似于普通数组的用法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++) <span class="hljs-comment">//a.size()返回数组元素个数</span><br>    &#123;<br>        a[i] = i+<span class="hljs-number">1</span>;<br>        cout&lt;&lt;a[i]&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;above is the first method&quot;</span>&lt;&lt;endl;<br><br>    <span class="hljs-comment">//第二种方案，使用迭代器</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = a.<span class="hljs-built_in">begin</span>(); it!= a.<span class="hljs-built_in">end</span>();it++) <span class="hljs-comment">//auto关键字一般使用来自动判断数据类型的，auto可以简化迭代器的声明</span><br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;endl; <span class="hljs-comment">//这里的it更像是指针</span><br>        *it = *it * <span class="hljs-number">2</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;after: &quot;</span>&lt;&lt;*it&lt;&lt;endl; <br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;above is the second method&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//前面两种，没办法直接判断数组越界</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        cout&lt;&lt;a.<span class="hljs-built_in">at</span>(i)&lt;&lt;endl;<br>        a.<span class="hljs-built_in">at</span>(i) = a.<span class="hljs-built_in">at</span>(i)*<span class="hljs-number">2</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;after: &quot;</span>&lt;&lt;a.<span class="hljs-built_in">at</span>(i)&lt;&lt;endl;<br>        <span class="hljs-comment">//a.at(5)就会抛出异常，在工程代码中非常有用 </span><br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;above is the third method&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test0</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> ### 数组的查找和排序数组array作为模板类，本身也提供了一系列查找方法，可以很方便对数组进行一些操作。在Algorithm库中，有sort函数可以使用，需要给出数组的首尾数据，默认是升序排列。如果要改变排序的方法，可以自己定义排序函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array b&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//初始化一个数组</span><br>    std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//默认升序排列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;item : b)<br>    &#123;<br>        std::cout&lt;&lt;item&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;after the sorting&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b; <span class="hljs-comment">//降序排列函数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array b&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//初始化一个数组</span><br>    std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),cmp); <span class="hljs-comment">//默认升序排列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;item : b)<br>    &#123;<br>        std::cout&lt;&lt;item&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;after the sorting: decend&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    array b&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//初始化一个数组</span><br>    std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//默认升序排列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp; item : b)<br>    &#123;<br>        std::cout&lt;&lt;item&lt;&lt;endl;<br>    &#125;<br>    cout &lt;&lt; std::<span class="hljs-built_in">binary_search</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),<span class="hljs-number">6</span>)&lt;&lt;endl;<br>    <span class="hljs-type">bool</span> flag&#123;std::<span class="hljs-built_in">binary_search</span>(b.<span class="hljs-built_in">begin</span>(),b.<span class="hljs-built_in">end</span>(),<span class="hljs-number">10</span>)&#125;; <span class="hljs-comment">//注意，实测降序无法使用二分查找</span><br>    <span class="hljs-keyword">if</span>(flag)<br>        cout&lt;&lt;<span class="hljs-string">&quot;I find it&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;Sorry I cannot find it&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//test1();</span><br>    <span class="hljs-comment">//test2();</span><br>    <span class="hljs-built_in">test3</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>其实还有一个点是多维数组，多维数组本质上是多个降一维度的数组迭加，有一个嵌套的使用在：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个二维数组，3行四列，注意这里声明的时候，行列的位置是反的</span><br>    std::array&lt;std::array&lt;<span class="hljs-type">int</span>, 4&gt;, 3&gt; myArray = &#123;&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;,<br>        &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;<br>    &#125;&#125;;<br>    <span class="hljs-comment">// std::array&lt;std::array&lt;int, 4&gt;, 3&gt; myArray&#123;std::array&#123;1, 2, 3, 4&#125;,std::array&#123;5, 6, 7, 8&#125;,std::array&#123;9, 10, 11, 12&#125;&#125;;</span><br>    <span class="hljs-comment">// 访问并输出数组元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>            std::cout &lt;&lt; myArray[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="函数式编程">函数式编程</h2><p>其实函数本身也可以作为“参数”传递给其他函数使用，函数式编程也具有“增量更新”的特性。原本在面向过程的开发流场中，稍微改动一个函数的功能，就要修改变量，可能会引入非常多的错误。C++中的函数编程是指利用函数作为一等公民（First-ClassCitizen）来编写程序，这意味着函数可以像其他类型的数据一样被传递、赋值、返回和操作。函数式编程强调函数的纯粹性和不可变性，鼓励使用无副作用的函数和避免共享状态。</p><p>函数可以作为参量被调用，也可以和函数模板配合： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// // 定义一个需要传入函数作为参数的函数</span><br><span class="hljs-comment">// void performOperation(int x, int y, int (*operation)(int, int)) &#123;</span><br><span class="hljs-comment">//     int result = operation(x, y);</span><br><span class="hljs-comment">//     std::cout &lt;&lt; &quot;The result is: &quot; &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 定义一个函数，用于相加</span><br><span class="hljs-comment">// int add(int a, int b) &#123;</span><br><span class="hljs-comment">//     return a + b;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 定义一个函数，用于相乘</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt; <span class="hljs-comment">//函数模板，不指定参数类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performOperation</span><span class="hljs-params">(T1 x, T1 y, T1 (*operation)(T1, T1))</span> </span>&#123; <span class="hljs-comment">//operation为别名</span><br>    T1 result = <span class="hljs-built_in">operation</span>(x, y);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The result is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 将相加函数作为参数传递给 performOperation 函数</span><br>    <span class="hljs-built_in">performOperation</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, add);<br><br>    <span class="hljs-built_in">performOperation</span>(<span class="hljs-number">3.5</span>, <span class="hljs-number">4.6</span>, add);<br><br>    <span class="hljs-comment">// 将相乘函数作为参数传递给 performOperation 函数</span><br>    <span class="hljs-built_in">performOperation</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, multiply);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h3 id="函数指针的声明和调用">函数指针的声明和调用</h3><p>在C++中，函数指针是指向函数的指针变量。它存储了函数的地址，可以通过函数指针调用相应的函数。</p><p>函数指针的声明和使用方式如下：</p><ol type="1"><li>声明函数指针：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">returnType</span> (*ptrName)(parameterTypes);<br></code></pre></td></tr></table></figure><p>这里的 returnType 是函数的返回类型，parameterTypes是函数的参数列表，ptrName 是函数指针的名称。</p><ol start="2" type="1"><li><p>将函数的地址赋给函数指针： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ptrName = functionName;<br></code></pre></td></tr></table></figure> 这里的 functionName是函数的名称，可以直接将函数名赋给函数指针。</p></li><li><p>通过函数指针调用函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">returnType result = (*ptrName)(arguments);<br></code></pre></td></tr></table></figure> 或者简写为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">returnType result = <span class="hljs-built_in">ptrName</span>(arguments);<br></code></pre></td></tr></table></figure>这里的 arguments 是函数的参数。 举一个实例： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//template&lt;class T&gt;</span><br><span class="hljs-comment">//using op = T(*) (T , T );</span><br><span class="hljs-keyword">using</span> Operation = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a*b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">double</span> a1 = <span class="hljs-number">11.1</span>, b1 = <span class="hljs-number">12.1</span>;<br>    Operation operation;<br>    operation = add;<br>    cout&lt;&lt;<span class="hljs-built_in">operation</span>(a,b)&lt;&lt;endl;<br>    operation = multiply;<br>    cout&lt;&lt;<span class="hljs-built_in">operation</span>(a,b)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><p>同样的，可以结合函数模板和函数指针，实现类似多态的效果，调用不同返回类型的函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义一个函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T value, <span class="hljs-type">void</span> (*func)(T))</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(value);<br>&#125;<br><br><span class="hljs-comment">// 定义两个不同的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Integer value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDouble</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Double value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用函数模板和函数指针实现多态效果</span><br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">5</span>, &amp;printInt);  <span class="hljs-comment">// 调用 printInt 函数</span><br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">3.14</span>, &amp;printDouble);  <span class="hljs-comment">// 调用 printDouble 函数</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Openfoam学习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openfoam学习记录 - 基本的文件结构</title>
      <link href="/2022/12/03/post03/"/>
      <url>/2022/12/03/post03/</url>
      
        <content type="html"><![CDATA[<h1 id="openfoam学习记录一---基本的文件结构">Openfoam学习记录一 -基本的文件结构</h1><p>从现在开始学习开源软件Openfoam并记录学习的过程。因为Openfoam的内容非常多非常杂，需要及时梳理方便回顾，并上手做一些小案例。我总觉得之前学习CFD不到位一个点就是太重视输入，不重视输出，不重视结果的讨论与分析，这是一个毛病，也是我在写使用Openfoam博客中想加入的东西来帮助自己改正。</p><p>这个学习记录博客素材的主要来源:Wolfdynamics培训资料(http://www.wolfdynamics.com/tutorials.html?layout=edit&amp;id=181)、武汉理工大学博士汪洋的培训课程及其开源的Openfoam入门培训讲义(B站名：大官人学CFD)、红宝书、Openfoam用户指南、以及CFD-ONLINE的论坛内容。因为是入门记录，所以内容上会有一些重合内容，对我来说也相当于是资料的整理和归纳。</p><h2 id="openfoam的文件结构">Openfoam的文件结构</h2><p>使用快捷命令foam可以直接进入主文件夹，在终端中输入tree -L 1可以看到：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Allwmake<br>├── COPYING<br>├── README.md<br>├── README.org<br>├── applications <span class="hljs-comment">#求解器，前后处理工具及其他工具源码</span><br>├── bin <span class="hljs-comment">#常用的脚本</span><br>├── doc <span class="hljs-comment">#Openfoam文档，需要使用Doxygen编译本地文档</span><br>├── etc <span class="hljs-comment">#环境文件夹</span><br>├── platforms<br>├── src<br>├── <span class="hljs-built_in">test</span><br>├── tutorials<br>└── wmake <br></code></pre></td></tr></table></figure>在Openfoam中的bashrc文件中，定义了Openfoam中的基本设置，包括并行核数、编译平台、并行MPI类型等等，另外还可以在$WM_PROJECT_DIR/etc/config.sh/aliases文件中给出了快捷指令的含义。例如foam是进入Openfoam中主文件夹，tut是进入自带案例文件夹。</p><p>常用的三个Linux命令</p><ol type="1"><li><p>grep命令：搜索命令，用来在输入文本的中搜索特定的内容，并输出到终端界面上，支持正则表达式匹配。用法是grep[option] 搜索内容 搜索文件，不同的option代表的含义的不同：-i：忽略字符大小写 -r：递归地搜索所有子目录-w：只匹配整个单词，而不是单词的一部分-v：反转搜索结果，即输出不包含匹配字符串的所有行-c：输出匹配到的行数而非匹配行的内容 grep -i "hello" file1.txt表示忽略大小写，在file1.txt中找到相应包含"hello"</p></li><li><p>find命令：在指定目录下查找文件和目录，使用不同的选项来过滤和限制查找的结果。用法是find[path] [expression]，find . -name"<strong>openfoam</strong>"，表示在当前文件夹下查找文件名中包含openfoam的文件，find/path/to/search -mtime -7找出7天内修改的文件，find /path/to/search-maxdepth 2 -name "*.txt"这个命令会在路径 /path/to/search及其子目录中查找扩展名为 .txt的文件，但只会搜索到第二层子目录，不会进一步递归下去。</p></li><li><p>awk命令：awk命令是一种经典的文本处理工具，主要用于在 Unix/Linux环境下对文本文件进行数据提取和格式化。可以接受一个或多个文件作为输入，然后按照给定的规则对每行数据进行处理，并输出结果到标准输出或指定的文件。用法awk'pattern { action }' filename。awk -F ',' '$2&gt;30 { print }'data.csv，输出 data.csv 文件中第二列大于30的行。</p></li></ol><h3 id="aplications文件夹">Aplications文件夹</h3><p>OpenFOAM的application文件夹存储了OpenFOAM中可执行程序的源代码和相关文件，主要是C++源代码和Makefile文件，并且使用OpenFOAM库进行编译。App文件内的内容非常重要，在该文件内做的修改会应用到Openfoam全局，所以需要用户自己建立专属于用户自己的App文件夹。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Allwmake<br>├── solvers <span class="hljs-comment">#各类求解器的源代码，以下是按照用途进行分类的源码</span><br>│   ├── DNS          <span class="hljs-comment">#直接数值模拟求解器</span><br>│   ├── acoustic<br>│   ├── basic        <br>│   ├── combustion   <span class="hljs-comment">#燃烧反应求解器</span><br>│   ├── compressible <span class="hljs-comment">#可压缩求解器</span><br>│   ├── discreteMethods<br>│   ├── doc <span class="hljs-comment">#文档</span><br>│   ├── electromagnetics<br>│   ├── financial<br>│   ├── finiteArea<br>│   ├── heatTransfer<br>│   ├── incompressible<br>│   ├── lagrangian<br>│   ├── multiphase <span class="hljs-comment">#多相流求解器</span><br>│   └── stressAnalysis<br>├── <span class="hljs-built_in">test</span>  <span class="hljs-comment">#测试文件夹</span><br>│   ├── 00-dummy<br>│   ├── 00-machine-sizes<br>│   ├── BinSum<br>│   ├── CircularBuffer<br>│   ├── Circulator<br>│   ├── CompactIOList<br>│   ├── DynamicList<br>│   ├── DynamicList2<br>│   ├── Enum<br>        ......<br>│<br>├── tools <span class="hljs-comment">#常用工具源码</span><br>│   ├── README.md<br>│   ├── foamCalc<br>│   └── foamExprParserInfo<br>└── utilities <span class="hljs-comment">#含了一些实用工具，用于处理网格、后处理、转换和可视化数据等任务。</span><br>    ├── doc<br>    ├── finiteArea<br>    ├── mesh<br>    ├── miscellaneous<br>    ├── parallelProcessing<br>    ├── postProcessing<br>    ├── preProcessing<br>    ├── surface<br>    └── thermophysical<br></code></pre></td></tr></table></figure></p><h3 id="bin文件夹">bin文件夹</h3><p>bin文件夹中包含了许多实用的shell脚本，每个脚本在激活Openfoam环境时，可以直接当做命令使用。例如foamCleanTutorials脚本，可以将所有的计算结果全部清空。paraFoam脚本可以直接启动paraview进行后处理。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── foamCheckJobs<br>├── foamCleanPath<br>├── foamCleanPolyMesh <span class="hljs-comment">#清除网格</span><br>├── foamCleanTutorials <span class="hljs-comment">#清除计算结果</span><br>├── foamCloneCase<br>├── foamCopySettings<br>├── foamCreateVideo<br>├── foamEndJob<br>├── foamEtcFile<br>├── foamGetDict<br>├── foamInstallationTest<br>├── foamJob<br>├── foamLog<br>├── foamMonitor<br>├── foamNew<br>├── foamNewApp <span class="hljs-comment">#创建自己app</span><br>├── foamNewBC <br>├── foamNewCase<br>├── foamNewFunctionObject<br>├── foamNewSource -&gt; ../etc/codeTemplates/source/foamNewSource<br>├── foamNewTemplate -&gt; ../etc/codeTemplates/template/foamNewTemplate<br>├── foamPrintJobs<br>├── foamRunTutorials<br>├── foamSearch<br>├── foamSequenceVTKFiles<br>├── foamSolverSweeps<br>├── foamSystemCheck<br>├── foamTestTutorial<br>├── mpirunDebug<br>├── paraFoam <span class="hljs-comment">#启动paraview后处理</span><br>└── tools<br>    ├── CleanFunctions<br>    ├── LogFunctions<br>    ├── MakefileDirs<br>    ├── README<br>       ......<br>    ├── doxyFilter.sed<br>    ├── findEmptyMake<br>    ├── foamConfigurePaths<br>    ├── foamCreateCompletionCache<br>    ├── foamCreateManpage<br>    ├── foamCreateModuleInclude<br>    ├── foamExec<br>    ├── foamGrepExeTargets<br>    ├── foamLog.db<br>    ├── foamPackRelease<br>    ├── foamUpdateCaseFileHeader<br>    ├── git-find-non-ascii<br>    ├── git-find-trailingspace<br>    ├── help-filter<br>    ├── install-dirs<br>    ├── install-platform<br>    ├── lib-dir<br>    ├── openfoam.in<br>    ├── pre-commit-hook<br>    ├── pre-receive-hook<br>    ├── query-detect<br>    ├── query-versions<br>    ├── source-bashrc<br>    ├── update-mpi-links.in<br>    └── vscode-settings<br></code></pre></td></tr></table></figure></p><h3 id="etc文件夹">etc文件夹</h3><p>etc文件夹中包含了许多环境配置文件，包括bashrc、各类模板、以及热物性库等等文件。其中caseDicts中，有许多输入文件的模板。对于自己编写自定义的文件有比较多的参考意义。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── bashrc<br>├── bashrc-e<br>├── caseDicts<br>├── cellModels<br>├── codeTemplates<br>├── colourTables<br>├── config.csh<br>├── config.sh<br>├── controlDict <br>├── cshrc<br>├── cshrc-e<br>├── openfoam<br>├── prefs.csh<br>├── prefs.sh<br>├── templates<br>└── thermoData<br></code></pre></td></tr></table></figure></p><h3 id="src文件夹">src文件夹</h3><p>src文件夹中包含了Openfoam最核心、最底层的源代码，其中包括求解器、网格生成器、库函数、物理模型等等。通常情况下，这些源代码需要进行修改，以便用户创建自己的定制应用程序。用户可以通过修改文本文件、头文件或使用C++等编程语言来实现自定义功能。app文件夹中的内容旨在解决流体动力学领域的各种问题。包括求解器和辅助工具，如网格生成器和后处理工具等。这些应用程序大多数都是不需要修改的，用户可以通过控制参数文件（system文件夹中）来设置运行选项。简单地说，src文件夹中的内容更为底层，是app文件夹中内容的基础。</p><p>对比src文件和app文件中的差异就是， <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── Allwmake<br>├── Allwmake-scan<br>├── ODE<br>├── OSspecific<br>├── OpenFOAM<br>├── Pstream<br>├── TurbulenceModels<br>├── atmosphericModels<br>├── combustionModels<br>├── conversion<br>├── dummyThirdParty<br>├── dynamicFaMesh<br>├── dynamicFvMesh<br>├── dynamicMesh<br>├── engine<br>├── faOptions<br>├── fileFormats <br>├── finiteArea<br>├── finiteVolume  <span class="hljs-comment">#提供有限体积法离散所需要的底层支持，网格离散、标量、矢量运算等等</span><br>├── functionObjects<br>├── fvAgglomerationMethods<br>├── fvMotionSolver<br>├── fvOptions<br>├── genericPatchFields<br>├── lagrangian<br>├── lumpedPointMotion<br>├── mesh<br>├── meshTools<br>├── optimisation<br>├── overset<br>├── parallel<br>├── phaseSystemModels<br>├── randomProcesses<br>├── regionFaModels<br>├── regionModels<br>├── renumber<br>├── rigidBodyDynamics<br>├── rigidBodyMeshMotion<br>├── sampling<br>├── sixDoFRigidBodyMotion<br>├── sixDoFRigidBodyState<br>├── surfMesh<br>├── thermoTools<br>├── thermophysicalModels<br>├── topoChangerFvMesh<br>├── transportModels<br>└── waveModels<br></code></pre></td></tr></table></figure></p><h3 id="platforms文件夹">platforms文件夹</h3><p>在编译appOpenfoam源代码和应用程序所生成的二进制文件和库文件都存放在该文件夹中。该文件夹内容十分重要，保存了开发程序所需要的所有库文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">. <br>├── linux64GccDPInt32Opt<br>│   ├── applications<br>│   ├── bin <span class="hljs-comment">#编译过程中所生成的二进制文件</span><br>│   ├── lib <span class="hljs-comment">#编译过程中所生成的库文件.so文件</span><br>│   └── src<br>└── linux64GccDPInt32OptSYSTEMOPENMPI<br>    └── src <span class="hljs-comment">#编译所需要的所有源文件，与src文件夹和app文件夹内容对应，但是其中是.o文件和.C.dep文件</span><br></code></pre></td></tr></table></figure></p><h2 id="小结">小结</h2><p>认识Openfoam的文件结构对我来说最大的帮助是理解一个大型项目构建的基本逻辑，怎么样去设计框架，例如openfoam将有关网格、前后处理、离散、基础模型放在src中，再将基于这些内容所开发的求解器放在app中，实现分离，将项目构建清晰。然后就是，在日常使用中，哪里出现问题了，可以对照去相应的文件夹找到参考内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Openfoam学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔：在超算-计算集群中编译安装OpenFOAM-5.x</title>
      <link href="/2022/11/30/blog02/"/>
      <url>/2022/11/30/blog02/</url>
      
        <content type="html"><![CDATA[<h1 id="安装的准备">安装的准备</h1><p>现在OpenFOAM已经更新到了第十版，之所以安装5版本，是因为我个人现在做CFD-DEM耦合的工作，CFDEM耦合软件支持的OpenFOAM就是5.x版本。不管是哪一个版本，安装过程和准备文件是基本一致的。安装过程主要参考如下博客和帖子： <a href="https://www.cfd-china.com/topic/4296/">https://www.cfd-china.com/topic/4296/</a>一种集群非root用户编译openfoam的方法-基于centos7<a href="https://blog.csdn.net/weixin_41734903/article/details/105125214">https://blog.csdn.net/weixin_41734903/article/details/105125214</a><a href="https://blog.csdn.net/weixin_42230462/article/details/115555172">https://blog.csdn.net/weixin_42230462/article/details/115555172</a></p><h2 id="文件清单">文件清单</h2><p>采用编译安装方式，首要就是准备好OpenFOAM的源代码，这个通过gitclone或者下载官网上的源码压缩包就可以了。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://github.com/OpenFOAM/OpenFOAM-5.x.git<br>git <span class="hljs-built_in">clone</span> git://github.com/OpenFOAM/ThirdParty-5.x.git<br></code></pre></td></tr></table></figure>由于在计算集群（超算）中，个人用户是没有安装底层库的权限的，且集群不连接外网，需要用户自己将一些必要的库准备好，然后传上去。超算平台和大型计算平台主要采用CentOS7系统，接下来的操作都以该系统为例。如果自己不清楚自己的系统版本，可以用uname-a命令查看系统版本，lsb_release -a可以查看属于什么操作系统。首先需要在自己的个人电脑上面安装一个与集群上系统一致的本地Linux虚拟机，个人可以使用VMwareworkstation play免费创建虚拟机。虚拟机的安装过程比较简单，不再赘述。在本地虚拟上，首先换源，换成国内源，下载软件速度快。然后安装yum-utils包，用来下载必须的依赖库。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su root <span class="hljs-comment">#在本地虚拟机上输入密码，切换成为root用户</span><br>yum -y install yum-utils<br></code></pre></td></tr></table></figure>然后下载OpenFOAM的依赖库，比较关键的有：binutils、boost、bison、flex、glibc、hwloc、m4、libtool、zlib，cmake这几个库的安装方式一致，以binutils为例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/<br><span class="hljs-built_in">mkdir</span> packages <span class="hljs-comment">#建立一个文件夹统一存放这些库</span><br><span class="hljs-built_in">cd</span> packages &amp;&amp; <span class="hljs-built_in">mkdir</span> binutils <span class="hljs-comment">#在packages下面建立一个文件夹存放binutils库</span><br>yumdownloader binutils <span class="hljs-comment">#下载这个库的软件包</span><br><span class="hljs-comment">#如果所有的库都按照这个顺序下载好了，可以先打包上传到集群中</span><br><span class="hljs-comment">#接下来就是解压库，然后将路径加入到bashrc，这里还是先在本地虚拟机操作，成功安装这些库，然后再在超算上实现一次</span><br><span class="hljs-built_in">cd</span> binutils<br>rpm2cpio binutils-2.27-44.base.el7_9.1.x86_64.rpm | cpio -idvm <span class="hljs-comment">#解压包，然后可以在binutils文件夹下面发现多出一个usr文件夹</span><br>vim ~/.bashrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/packages/binutils/usr/bin <span class="hljs-comment">#将库文件目录加入到系统目录中，至此，这个库已经装好了</span><br><br><span class="hljs-comment">#重复以上步骤，依次安装所有的库，现在本地安装通过，再在超算上重复操作。保持两者一致性。</span><br></code></pre></td></tr></table></figure>这里有一个值得一说的点，由于CentOS7默认的gcc版本是4.85，刚好符号OpenFOAM-5.x安装要求，我并没有再安装gcc，gcc版本太旧或者太新都会导致编译出错。然后是安装openmpi，从安装角度，这个是OpenFOAM最推荐使用的并行库，且集群中，最好只有这个并行库，mpich可能会和openmpi起冲突。如果使用intelmpi，会在AMD核心集群上存在兼容性问题。如果集群中安装了别的并行库，最好先卸载掉。检查OpenFOAM-5.x使用的是openmpi2.1版本，从Openmpi官网上下载源码，在本地和集群中都保留一份。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/<br><span class="hljs-built_in">mkdir</span> openmpi <span class="hljs-comment">#建立openmpi的安装路径</span><br><span class="hljs-built_in">cd</span> OpenFOAM<br><span class="hljs-built_in">cd</span> Third-party-5.x/ <span class="hljs-comment">#最好将openmpi源码解压到此文件夹下，因为可能会有一些找不到文件的错误</span><br>tar -zxvf openmpi-2.1.1.tar.gz <span class="hljs-comment">#解压openmpi的源码</span><br><span class="hljs-built_in">cd</span> openmpi-2.1.1/<br>./configure --prefix=/home/username/openmpi/ <span class="hljs-comment">#配置openmpi</span><br>make &amp;&amp; make install <span class="hljs-comment">#耐心等待安装完成</span><br></code></pre></td></tr></table></figure> username是自己的账户名，不是就打一个"username"就可以了如果在openmpi编译过程中，出现了“****-l和-lr之间没有空格”这个编译错误，是openmpi的一个bug，将配置语句改成<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/home/username/openmpi --with-ucx=/usr<br></code></pre></td></tr></table></figure>就可以正常编译，然后没有错误以后，将openmpi的路径加入到系统路径中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/openmpi/bin<br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/home/username/openmpi/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br><span class="hljs-built_in">source</span> ~/.bashrc <span class="hljs-comment">#让配置文件生效</span><br></code></pre></td></tr></table></figure> 如果没有报错，可以运行一下mpicc或者whichmpicc，如果没有出现mpicc notfound这样的错误，并且显示了mpicc的路径就是安装成功了。</p><h1 id="编译openfoam-5.x">编译OpenFOAM-5.x</h1><p>到这里，我个人建议，是本地虚拟机和计算集群都执行一样的操作，保持一致性。这样也方便以后自己程序的调试，至于还有一个作用，在文末可以看到。首先，需要将OpenFOAM的环境说明写入系统.bashrc文件里面： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> <span class="hljs-variable">$HOME</span>/OpenFOAM/OpenFOAM-5.x/etc/bashrc WM_LABEL_SIZE=64 WM_COMPILER_TYPE=system WM_COMPILER=Gcc WM_MPLIB=OPENMPI <br></code></pre></td></tr></table></figure>如果没有报错，说明可以正式编译OpenFOAM了，先进入到Third-party下面：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./Allclean<br>./Allwmake -j4<br><span class="hljs-comment">#如果在集群上，可以用更多核心编译，速度会变快 srun -c64 ./Allwmake -j64</span><br></code></pre></td></tr></table></figure> 如果编译顺利通过，可以编译OpenFOAM: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/OpenFOAM/OpenFOAM-5.x<br>./Allwmake -j4 <span class="hljs-comment">#耗时数小时</span><br><span class="hljs-comment">#同理如果在集群上，可以用更多核心编译，速度会变快 srun -c64 ./Allwmake -j64</span><br></code></pre></td></tr></table></figure>如果没有报错，可以执行一下blockMesh，如果看到出现OpenFOAM的标志，就是安装成功了<img src="https://cdn.nlark.com/yuque/0/2022/png/34567141/1669996035908-f8cdf2e6-bd70-412c-9b9c-6f5b489cc556.png#averageHue=%23fcfcfc&amp;clientId=u417a18bd-49e7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=346&amp;id=u284e3e3e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=914&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=150713&amp;status=done&amp;style=none&amp;taskId=u75ff3184-01f4-48ed-a678-871b005d833&amp;title=&amp;width=914" alt="image.png"></p><h1 id="可能遇到的错误">可能遇到的错误</h1><p>目前我遇到的错误，绝大多数情况都是找不到mpi.h，这个是由于openmpi没有配置好。如果按照文中的步骤，最后能看到mpi的环境成功配置应该就没有问题。其次，找不到****.h或者***.c大部分是因为缺少依赖库。例如我一开始在本地虚拟机安装了glibc，libtool库，但是集群中没有，编译一直不过，这个时候建议首先检查依赖库。最后一个，如果Third-party能够成功编译，基本上OpenFOAM也能顺利编译，如果最后实在是编译不过，也找不到原因。可以将本地编译好的Thirdparty打包上传到集群再解压，然后再重新编译，这也是为什么要保持本地虚拟机和集群，操作系统以及安装操作一致性的原因。因为本地虚拟机，权限和上网可控，但是集群都不行，本地的编译出现问题较容易解决。最后看一下我自己的.bashrc文件 <img src="https://cdn.nlark.com/yuque/0/2022/png/34567141/1669996433706-a2323a2a-3a2f-4a42-aac0-f72f887a5100.png#averageHue=%23f6f9e9&amp;clientId=u417a18bd-49e7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u51a4108e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=235&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=161333&amp;status=done&amp;style=none&amp;taskId=u101bf169-95f6-4f9e-8754-ba3cd834169&amp;title=&amp;width=480" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 偏微分方程数值解 </tag>
            
            <tag> CFD </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOOSE多物理场耦合平台入门学习记录（二）- 牛顿法求解非线性方程组</title>
      <link href="/2022/07/05/blog01/"/>
      <url>/2022/07/05/blog01/</url>
      
        <content type="html"><![CDATA[<p>放在首页的话：本人撰写博客最主要的目的是整理自己对研究对象的认识，积累经验，加深理解。自身水平并不高，很多都是靠自学。如果有大佬看出其中的错误或者有新的角度理解，还请留言指点，非常感谢，这对于我水平提高有很大的帮助。</p><h1 id="牛顿法的简介">牛顿法的简介</h1><p>NEWTONSolver是MOOSE平台三大求解器之一（NEWTON、JFNK、PJFNK），简要了解牛顿法的基本原理对于理解MOOSE平台的底层机制有一定帮助，也能帮助判断使用NEWTONsolver收敛失败的原因。本博文主要参考这篇文章(https://zhuanlan.zhihu.com/p/139595720)，以及一个非常简洁明了的教学视频(https://www.bilibili.com/video/BV19Q4y1S7dR?spm_id_from=333.337.search-card.all.click&amp;vd_source=b154dc71d458a24aaa3478de44369f37)。</p><h2 id="牛顿法求解非线性方程">牛顿法求解非线性方程</h2><p>大多数数值分析的教科书都是首先介绍牛顿法求解非线性方程。牛顿法的基本思想来自于泰勒公式，假设现存一个非线性方程<span class="math inline">\(y = f(x) =b\)</span>，首先将方程转化为求根问题，即<span class="math inline">\(F(x)= f(x)-b=0\)</span>。在某一点<span class="math inline">\(x_0\)</span>处，进行泰勒展开，可以得到： <span class="math display">\[F(x) = F(x_0) + F^{&#39;}(x - x_0) + \frac{F^{&#39;&#39;}(x_0)}{2}(x -x_0)^2 + O(\Delta x) \tag{1}\]</span> 对于线性方程，仅取一阶近似就可以满足要求，可以得到: <span class="math display">\[\begin{array}{c}    F(x_0) + F^{&#39;}(x - x_0) = 0 \\    x = x_0 - \frac{F(x_0)}{F^{&#39;}(x_0)}\end{array} \tag{2}\]</span> 显然此时的<span class="math inline">\(x\)</span>并不可能直接就是方程的根，但是可以重复迭代，使得<span class="math inline">\(x\)</span>不断逼近方程根，直到满足要求。从图像上看，其过程就是，在一个方程所表达的曲线上选取一个点<span class="math inline">\(x_0\)</span>，然后在该点做与曲线的切线，切线与x轴相交的点，其坐标值就是下一步迭代的<span class="math inline">\(x_1\)</span>，然后再<span class="math inline">\(x_1\)</span>所对应曲线上的点，继续做切线，切线与x轴相交的点<span class="math inline">\(x_3\)</span>，反复重复上述过程，直到<span class="math inline">\(x_n\)</span>达到预设误差的要求。</p><p>但是，对于需要求解函数的极值问题，取一阶近似就不能满足要求了，需要将其转化为求解其导数为0问题，再使用牛顿法，因此，常见求解非线性方程选取的是二阶近似：<span class="math display">\[\begin{array}{c}    F(x) = F(x_0) + F^{&#39;}(x - x_0) + \frac{F^{&#39;&#39;}(x_0)}{2}(x- x_0)^2 = 0\end{array} \tag{3}\]</span> 对上式，左右再进行求导可以得到: <span class="math display">\[\begin{array}{c}    F^{&#39;}(x_0) + F^{&#39;&#39;}(x - x_0) = 0 \\    x = x_0 - \frac{F^{&#39;}(x_0)}{F^{&#39;&#39;}(x_0)}\end{array} \tag{4}\]</span>可以看到，牛顿法使用的前提，是曲线导数存在，而在实际使用中，求导数是一个非常难处理的问题，可以使用差分来近似。</p><h2 id="牛顿法求解非线性方程的编程实现">牛顿法求解非线性方程的编程实现</h2><p>以方程<span class="math inline">\(x^2 - 2x -3 =0,x&gt;0\)</span>为例，其一阶导数和二阶导数分别是<span class="math inline">\(2x-2, 2\)</span>，代码如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x*x - <span class="hljs-number">2</span>*x - <span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">firstOD</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#一阶导数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x - <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">secondOD</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#二阶导数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-comment"># 以下为一阶近似牛顿法</span><br>x0 = <span class="hljs-number">0.0</span> <span class="hljs-comment">#初始值</span><br>err_limit = <span class="hljs-number">1e-10</span> <span class="hljs-comment">#误差限</span><br>err_iter = <span class="hljs-number">1.0</span><br>iter_num = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span>(err_iter &gt; err_limit):<br>    xn = x0 - F(x0)/firstOD(x0)<br>    err_iter = <span class="hljs-built_in">abs</span>(xn - x0)<br>    x0 = xn<br>    iter_num = iter_num + <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The iter num for Newton method 1st is &#x27;</span> + <span class="hljs-built_in">str</span>(iter_num))<br></code></pre></td></tr></table></figure></p><p>示例方程确实太简单了，也可以看到，单纯使用牛顿法编程并不复杂（前提是导数易求解和易计算），还有就是初值的影响非常大，第一个是初值选取不当，容易陷入初值陷阱，计算失败。第二个就是可能迭代不到想要的解，如上面的方程，应该有两个根，如果初值选取小于1.0，则是求解的-1的根，但是实际想要的是<span class="math inline">\(x&gt;0\)</span>的解。因为牛顿法单次只能搜寻某个局部区间的解。因此在使用牛顿法前，对方程的几何特性最好要有一定把握。</p><h2 id="牛顿法求解非线性方程组">牛顿法求解非线性方程组</h2><p>如果是方程组，那么解就不是一个单个的数，而是一个解向量<span class="math inline">\([x_0,x_1,x_2,\cdots,x_n]\)</span>，对应方程组为:<span class="math display">\[\begin{bmatrix}    f_{1}(x_0,x_1,x_2,\cdots,x_n)  \\    f_{2}(x_0,x_1,x_2,\cdots,x_n) \\    f_{3}(x_0,x_1,x_2,\cdots,x_n) \\      \vdots \\    f_{n}(x_0,x_1,x_2,\cdots,x_n)\end{bmatrix} =\begin{bmatrix}    0 \\    0 \\    0 \\    \vdots \\    0\end{bmatrix} \tag{5}\]</span>对左侧矩阵中的每一项使用多元泰勒展开，与前述过程类似，取一阶梯度，写成迭代格式，可以得到：<span class="math display">\[\begin{array}{c}    F(X^{k}) + \nabla F(X^{k})(X^{k+1} - X^{k}) = 0 \\    (X^{k+1} - X^{k}) =  - \nabla F(X^{k})^{-1}F(X^{k})\end{array} \tag{6}\]</span> 上式中，<span class="math inline">\(\nabla F(X^{k})\)</span>就是常见的Jacbobian矩阵，注意，上式中，已经不是简单的乘除法，而是涉及到矩阵求逆运算，并不满足交换律。X也是一个解向量，而不是一个单个数值。Jacbobian矩阵的形式如下：<span class="math display">\[\begin{bmatrix}    \frac{\partial f_1}{\partial x_0} &amp; \frac{\partial f_1}{\partialx_1} &amp; \cdots &amp;  \frac{\partial f_1}{\partial x_n} \\    \frac{\partial f_2}{\partial x_0} &amp; \frac{\partial f_2}{\partialx_1} &amp; \cdots  &amp; \frac{\partial f_2}{\partial x_n} \\    \vdots&amp;\vdots&amp; \ddots &amp; \vdots \\    \frac{\partial f_n}{\partial x_0} &amp; \frac{\partial f_n}{\partialx_1} &amp; \cdots  &amp;\frac{\partial f_n}{\partial x_n}\end{bmatrix}\]</span></p><h2 id="牛顿法求解非线性方程组的编程实现">牛顿法求解非线性方程组的编程实现</h2><p>以如下方程为示例，其几何意义就是一直线与圆相交的两点。这里仅考虑y&gt;0的解：<span class="math display">\[\begin{cases}    x^2 + y^2 = 16 \\    y -\sqrt{3}x = 0\end{cases} \tag{7}\]</span> 待求解方程和Jacobian矩阵如下： <span class="math display">\[\begin{cases}    x^2 + y^2 -16 = 0 \\    -\sqrt{3}x + y -4 =0\end{cases},\begin{bmatrix}    2x &amp; 2y \\    -\sqrt{3} &amp; 1\end{bmatrix}\]</span> 代入6式中的迭代表达式： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#以下为牛顿法求解方程组程序</span><br>    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f11</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#四个偏导数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f12</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f21</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>*sqrt(<span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f22</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">err_cal</span>(<span class="hljs-params">a,b</span>): <span class="hljs-comment">#计算误差，不同的误差统计方法函数不同，这里采用平方和</span><br>        n = np.size(a,axis=<span class="hljs-number">0</span>)<br>        err_sum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            err_sum = err_sum + (a[i] - b[i])**<span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> sqrt(err_sum)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Jacobian_cal</span>(<span class="hljs-params">x</span>):<br>        n = np.size(x,axis=<span class="hljs-number">0</span>)<br>        tempm = np.zeros([n,n])<br>        tempm[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = f11(x)<br>        tempm[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = f12(x)<br>        tempm[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = f21(x)<br>        tempm[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = f22(x)<br>        <span class="hljs-keyword">return</span> tempm<br>    err_limit = <span class="hljs-number">1e-5</span><br>    err_iter = <span class="hljs-number">1</span><br>    xi = np.zeros([<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])<br>    xi[<span class="hljs-number">0</span>] = <span class="hljs-number">3.0</span><br>    xi[<span class="hljs-number">1</span>] = <span class="hljs-number">2.0</span><br>    JM = np.zeros([<span class="hljs-number">4</span>,<span class="hljs-number">4</span>])<br>    iter_num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(err_iter &gt; err_limit):<br>        JM = Jacobian_cal(xi)<br>        xi_old = xi.copy()<br>        F = np.zeros([<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])<br>        F[<span class="hljs-number">0</span>] = xi[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> + xi[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span> - <span class="hljs-number">16</span><br>        F[<span class="hljs-number">1</span>] = -sqrt(<span class="hljs-number">3</span>)*xi[<span class="hljs-number">0</span>] + xi[<span class="hljs-number">1</span>]<span class="hljs-comment">#计算F(x^k)</span><br>        <span class="hljs-built_in">print</span>(F)<br>        tempjms = np.linalg.inv(JM) <span class="hljs-comment">#对Jacobian矩阵求逆</span><br>        Rn = -<span class="hljs-number">1</span>*tempjms.dot(F)<br>        xi = xi + Rn <span class="hljs-comment">#计算xi+1，作为下一步迭代初始值</span><br>        err_iter = err_cal(xi_old,xi) <span class="hljs-comment">#计算迭代误差</span><br>        iter_num = iter_num + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(xi)  <span class="hljs-comment">#输出结果</span><br>    <span class="hljs-built_in">print</span>(iter_num)<br></code></pre></td></tr></table></figure>在牛顿法中，Jacobian矩阵的性质决定了迭代的结果好坏，有可能会出现如下情况：</p><ol type="1"><li>Jacobian矩阵迭代过程中产生奇异，不可以再求逆，迭代就会失败。</li><li>由于求解导数，以及矩阵求逆本身就是很复杂的运算，需要耗费大量计算资源，很容易出现错误，这与方程本身的特性相关。例如，上面方程如果x和y的系数互为相反数，则难以迭代出正确解。</li><li>初值选取不当，造成了后面一系列迭代计算的恶化。</li></ol><p>如果准确求解Jacobian矩阵并且保持迭代过程中矩阵有良好的计算特性是应用牛顿法的大问题。同时也可以看到，牛顿法求解方程组是所有方程同步求解的，并不是类似Picard迭代一样，完成一个场的计算再代入另一个场计算，有利于考虑不同物理场方程之间的高度非线性耦合关系，但是计算要求也更高。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 偏微分方程数值解 </tag>
            
            <tag> 有限差分法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
