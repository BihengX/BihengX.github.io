<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Openfoam学习记录 - 基本的文件结构</title>
    <link href="/2022/12/03/post3/"/>
    <url>/2022/12/03/post3/</url>
    
    <content type="html"><![CDATA[<h1 id="openfoam学习记录一---基本的文件结构">Openfoam学习记录一 -基本的文件结构</h1><p>从现在开始学习开源软件Openfoam并记录学习的过程。因为Openfoam的内容非常多非常杂，需要及时梳理方便回顾，并上手的做一些小案例。我总觉得之前学习CFD不到位一个点就是太重视输入，不重视输出，不重视结果的讨论与分析，这是一个毛病，也是我在写使用Openfoam博客中想加入的东西来帮助自己改正。</p><p>这个学习记录博客素材的主要来源:Wolfdynamics培训资料(http://www.wolfdynamics.com/tutorials.html?layout=edit&amp;id=181)、武汉理工大学博士汪洋的培训课程及其开源的Openfoam入门培训讲义(B站名：大官人学CFD)、红宝书、Openfoam用户指南、以及CFD-ONLINE的论坛内容。因为是入门记录，所以内容上会有一些重合内容，对我来说也相当于是资料的整理和归纳。</p><h2 id="openfoam的文件结构">Openfoam的文件结构</h2><p>使用快捷命令foam可以直接进入主文件夹，在终端中输入tree -L 1可以看到：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Allwmake<br>├── COPYING<br>├── README.md<br>├── README.org<br>├── applications <span class="hljs-comment">#求解器，前后处理工具及其他工具源码</span><br>├── bin <span class="hljs-comment">#常用的脚本</span><br>├── doc <span class="hljs-comment">#Openfoam文档，需要使用Doxygen编译本地文档</span><br>├── etc <span class="hljs-comment">#环境文件夹</span><br>├── platforms<br>├── src<br>├── <span class="hljs-built_in">test</span><br>├── tutorials<br>└── wmake <br></code></pre></td></tr></table></figure>在Openfoam中的bashrc文件中，定义了Openfoam中的基本设置，包括并行核数、编译平台、并行MPI类型等等，另外还可以在$WM_PROJECT_DIR/etc/config.sh/aliases文件中给出了快捷指令的含义。例如foam是进入Openfoam中主文件夹，tut是进入自带案例文件夹。</p><p>常用的三个Linux命令 1.grep命令：搜索命令，用来在输入文本的中搜索特定的内容，并输出到终端界面上，支持正则表达式匹配。用法是grep[option] 搜索内容 搜索文件，不同的option代表的含义的不同：-i：忽略字符大小写 -r：递归地搜索所有子目录-w：只匹配整个单词，而不是单词的一部分-v：反转搜索结果，即输出不包含匹配字符串的所有行-c：输出匹配到的行数而非匹配行的内容 grep -i "hello" file1.txt表示忽略大小写，在file1.txt中找到相应包含"hello"</p><ol start="2" type="1"><li><p>find命令：在指定目录下查找文件和目录，使用不同的选项来过滤和限制查找的结果。用法是find[path] [expression]，find . -name"<strong>openfoam</strong>"，表示在当前文件夹下查找文件名中包含openfoam的文件，find/path/to/search -mtime -7找出7天内修改的文件，find /path/to/search-maxdepth 2 -name "*.txt"这个命令会在路径 /path/to/search及其子目录中查找扩展名为 .txt的文件，但只会搜索到第二层子目录，不会进一步递归下去。</p></li><li><p>awk命令：awk命令是一种经典的文本处理工具，主要用于在 Unix/Linux环境下对文本文件进行数据提取和格式化。可以接受一个或多个文件作为输入，然后按照给定的规则对每行数据进行处理，并输出结果到标准输出或指定的文件。用法awk'pattern { action }' filename。awk -F ',' '$2&gt;30 { print }'data.csv，输出 data.csv 文件中第二列大于30的行。</p></li></ol><h3 id="aplications文件夹">Aplications文件夹</h3><p>OpenFOAM的application文件夹存储了OpenFOAM中可执行程序的源代码和相关文件，主要是C++源代码和Makefile文件，并且使用OpenFOAM库进行编译。App文件内的内容非常重要，在该文件内做的修改会应用到Openfoam全局，所以需要用户自己建立专属于用户自己的App文件夹。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Allwmake<br>├── solvers <span class="hljs-comment">#各类求解器的源代码，以下是按照用途进行分类的源码</span><br>│   ├── DNS          <span class="hljs-comment">#直接数值模拟求解器</span><br>│   ├── acoustic<br>│   ├── basic        <br>│   ├── combustion   <span class="hljs-comment">#燃烧反应求解器</span><br>│   ├── compressible <span class="hljs-comment">#可压缩求解器</span><br>│   ├── discreteMethods<br>│   ├── doc <span class="hljs-comment">#文档</span><br>│   ├── electromagnetics<br>│   ├── financial<br>│   ├── finiteArea<br>│   ├── heatTransfer<br>│   ├── incompressible<br>│   ├── lagrangian<br>│   ├── multiphase <span class="hljs-comment">#多相流求解器</span><br>│   └── stressAnalysis<br>├── <span class="hljs-built_in">test</span>  <span class="hljs-comment">#测试文件夹</span><br>│   ├── 00-dummy<br>│   ├── 00-machine-sizes<br>│   ├── BinSum<br>│   ├── CircularBuffer<br>│   ├── Circulator<br>│   ├── CompactIOList<br>│   ├── DynamicList<br>│   ├── DynamicList2<br>│   ├── Enum<br>        ......<br>│<br>├── tools <span class="hljs-comment">#常用工具源码</span><br>│   ├── README.md<br>│   ├── foamCalc<br>│   └── foamExprParserInfo<br>└── utilities <span class="hljs-comment">#含了一些实用工具，用于处理网格、后处理、转换和可视化数据等任务。</span><br>    ├── doc<br>    ├── finiteArea<br>    ├── mesh<br>    ├── miscellaneous<br>    ├── parallelProcessing<br>    ├── postProcessing<br>    ├── preProcessing<br>    ├── surface<br>    └── thermophysical<br></code></pre></td></tr></table></figure></p><h3 id="bin文件夹">bin文件夹</h3><p>bin文件夹中包含了许多实用的shell脚本，每个脚本在激活Openfoam环境时，可以直接当做命令使用。例如foamCleanTutorials脚本，可以将所有的计算结果全部清空。paraFoam脚本可以直接启动paraview进行后处理。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── foamCheckJobs<br>├── foamCleanPath<br>├── foamCleanPolyMesh <span class="hljs-comment">#清除网格</span><br>├── foamCleanTutorials <span class="hljs-comment">#清除计算结果</span><br>├── foamCloneCase<br>├── foamCopySettings<br>├── foamCreateVideo<br>├── foamEndJob<br>├── foamEtcFile<br>├── foamGetDict<br>├── foamInstallationTest<br>├── foamJob<br>├── foamLog<br>├── foamMonitor<br>├── foamNew<br>├── foamNewApp <span class="hljs-comment">#创建自己app</span><br>├── foamNewBC <br>├── foamNewCase<br>├── foamNewFunctionObject<br>├── foamNewSource -&gt; ../etc/codeTemplates/source/foamNewSource<br>├── foamNewTemplate -&gt; ../etc/codeTemplates/template/foamNewTemplate<br>├── foamPrintJobs<br>├── foamRunTutorials<br>├── foamSearch<br>├── foamSequenceVTKFiles<br>├── foamSolverSweeps<br>├── foamSystemCheck<br>├── foamTestTutorial<br>├── mpirunDebug<br>├── paraFoam <span class="hljs-comment">#启动paraview后处理</span><br>└── tools<br>    ├── CleanFunctions<br>    ├── LogFunctions<br>    ├── MakefileDirs<br>    ├── README<br>       ......<br>    ├── doxyFilter.sed<br>    ├── findEmptyMake<br>    ├── foamConfigurePaths<br>    ├── foamCreateCompletionCache<br>    ├── foamCreateManpage<br>    ├── foamCreateModuleInclude<br>    ├── foamExec<br>    ├── foamGrepExeTargets<br>    ├── foamLog.db<br>    ├── foamPackRelease<br>    ├── foamUpdateCaseFileHeader<br>    ├── git-find-non-ascii<br>    ├── git-find-trailingspace<br>    ├── help-filter<br>    ├── install-dirs<br>    ├── install-platform<br>    ├── lib-dir<br>    ├── openfoam.in<br>    ├── pre-commit-hook<br>    ├── pre-receive-hook<br>    ├── query-detect<br>    ├── query-versions<br>    ├── source-bashrc<br>    ├── update-mpi-links.in<br>    └── vscode-settings<br></code></pre></td></tr></table></figure></p><h3 id="etc文件夹">etc文件夹</h3><p>etc文件夹中包含了许多环境配置文件，包括bashrc、各类模板、<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── bashrc<br>├── bashrc-e<br>├── caseDicts<br>├── cellModels<br>├── codeTemplates<br>├── colourTables<br>├── config.csh<br>├── config.sh<br>├── controlDict <br>├── cshrc<br>├── cshrc-e<br>├── openfoam<br>├── prefs.csh<br>├── prefs.sh<br>├── templates<br>└── thermoData<br></code></pre></td></tr></table></figure></p><h3 id="src文件夹">src文件夹</h3><p>src文件夹中包含了Openfoam最核心、最底层的源代码，其中包括求解器、网格生成器、库函数、物理模型等等。通常情况下，这些源代码需要进行修改，以便用户创建自己的定制应用程序。用户可以通过修改文本文件、头文件或使用C++等编程语言来实现自定义功能。app文件夹中的内容旨在解决流体动力学领域的各种问题。包括求解器和辅助工具，如网格生成器和后处理工具等。这些应用程序大多数都是不需要修改的，用户可以通过控制参数文件（system文件夹中）来设置运行选项。简单地说，src文件夹中的内容更为底层，是app文件夹中内容的基础。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Openfoam学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔：在超算-计算集群中编译安装OpenFOAM-5.x</title>
    <link href="/2022/11/30/blog02/"/>
    <url>/2022/11/30/blog02/</url>
    
    <content type="html"><![CDATA[<h1 id="安装的准备">安装的准备</h1><p>现在OpenFOAM已经更新到了第十版，之所以安装5版本，是因为我个人现在做CFD-DEM耦合的工作，CFDEM耦合软件支持的OpenFOAM就是5.x版本。不管是哪一个版本，安装过程和准备文件是基本一致的。安装过程主要参考如下博客和帖子： <ahref="https://www.cfd-china.com/topic/4296/">https://www.cfd-china.com/topic/4296/</a>一种集群非root用户编译openfoam的方法-基于centos7<ahref="https://blog.csdn.net/weixin_41734903/article/details/105125214">https://blog.csdn.net/weixin_41734903/article/details/105125214</a><ahref="https://blog.csdn.net/weixin_42230462/article/details/115555172">https://blog.csdn.net/weixin_42230462/article/details/115555172</a></p><h2 id="文件清单">文件清单</h2><p>采用编译安装方式，首要就是准备好OpenFOAM的源代码，这个通过gitclone或者下载官网上的源码压缩包就可以了。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://github.com/OpenFOAM/OpenFOAM-5.x.git<br>git <span class="hljs-built_in">clone</span> git://github.com/OpenFOAM/ThirdParty-5.x.git<br></code></pre></td></tr></table></figure>由于在计算集群（超算）中，个人用户是没有安装底层库的权限的，且集群不连接外网，需要用户自己将一些必要的库准备好，然后传上去。超算平台和大型计算平台主要采用CentOS7系统，接下来的操作都以该系统为例。如果自己不清楚自己的系统版本，可以用uname-a命令查看系统版本，lsb_release -a可以查看属于什么操作系统。首先需要在自己的个人电脑上面安装一个与集群上系统一致的本地Linux虚拟机，个人可以使用VMwareworkstation play免费创建虚拟机。虚拟机的安装过程比较简单，不再赘述。在本地虚拟上，首先换源，换成国内源，下载软件速度快。然后安装yum-utils包，用来下载必须的依赖库。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su root <span class="hljs-comment">#在本地虚拟机上输入密码，切换成为root用户</span><br>yum -y install yum-utils<br></code></pre></td></tr></table></figure>然后下载OpenFOAM的依赖库，比较关键的有：binutils、boost、bison、flex、glibc、hwloc、m4、libtool、zlib，cmake这几个库的安装方式一致，以binutils为例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/<br><span class="hljs-built_in">mkdir</span> packages <span class="hljs-comment">#建立一个文件夹统一存放这些库</span><br><span class="hljs-built_in">cd</span> packages &amp;&amp; <span class="hljs-built_in">mkdir</span> binutils <span class="hljs-comment">#在packages下面建立一个文件夹存放binutils库</span><br>yumdownloader binutils <span class="hljs-comment">#下载这个库的软件包</span><br><span class="hljs-comment">#如果所有的库都按照这个顺序下载好了，可以先打包上传到集群中</span><br><span class="hljs-comment">#接下来就是解压库，然后将路径加入到bashrc，这里还是先在本地虚拟机操作，成功安装这些库，然后再在超算上实现一次</span><br><span class="hljs-built_in">cd</span> binutils<br>rpm2cpio binutils-2.27-44.base.el7_9.1.x86_64.rpm | cpio -idvm <span class="hljs-comment">#解压包，然后可以在binutils文件夹下面发现多出一个usr文件夹</span><br>vim ~/.bashrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/packages/binutils/usr/bin <span class="hljs-comment">#将库文件目录加入到系统目录中，至此，这个库已经装好了</span><br><br><span class="hljs-comment">#重复以上步骤，依次安装所有的库，现在本地安装通过，再在超算上重复操作。保持两者一致性。</span><br></code></pre></td></tr></table></figure>这里有一个值得一说的点，由于CentOS7默认的gcc版本是4.85，刚好符号OpenFOAM-5.x安装要求，我并没有再安装gcc，gcc版本太旧或者太新都会导致编译出错。然后是安装openmpi，从安装角度，这个是OpenFOAM最推荐使用的并行库，且集群中，最好只有这个并行库，mpich可能会和openmpi起冲突。如果使用intelmpi，会在AMD核心集群上存在兼容性问题。如果集群中安装了别的并行库，最好先卸载掉。检查OpenFOAM-5.x使用的是openmpi2.1版本，从Openmpi官网上下载源码，在本地和集群中都保留一份。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/<br><span class="hljs-built_in">mkdir</span> openmpi <span class="hljs-comment">#建立openmpi的安装路径</span><br><span class="hljs-built_in">cd</span> OpenFOAM<br><span class="hljs-built_in">cd</span> Third-party-5.x/ <span class="hljs-comment">#最好将openmpi源码解压到此文件夹下，因为可能会有一些找不到文件的错误</span><br>tar -zxvf openmpi-2.1.1.tar.gz <span class="hljs-comment">#解压openmpi的源码</span><br><span class="hljs-built_in">cd</span> openmpi-2.1.1/<br>./configure --prefix=/home/username/openmpi/ <span class="hljs-comment">#配置openmpi</span><br>make &amp;&amp; make install <span class="hljs-comment">#耐心等待安装完成</span><br></code></pre></td></tr></table></figure> username是自己的账户名，不是就打一个"username"就可以了如果在openmpi编译过程中，出现了“****-l和-lr之间没有空格”这个编译错误，是openmpi的一个bug，将配置语句改成<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/home/username/openmpi --with-ucx=/usr<br></code></pre></td></tr></table></figure>就可以正常编译，然后没有错误以后，将openmpi的路径加入到系统路径中：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bashrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/openmpi/bin<br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/home/username/openmpi/lib:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br><span class="hljs-built_in">source</span> ~/.bashrc <span class="hljs-comment">#让配置文件生效</span><br></code></pre></td></tr></table></figure> 如果没有报错，可以运行一下mpicc或者whichmpicc，如果没有出现mpicc notfound这样的错误，并且显示了mpicc的路径就是安装成功了。</p><h1 id="编译openfoam-5.x">编译OpenFOAM-5.x</h1><p>到这里，我个人建议，是本地虚拟机和计算集群都执行一样的操作，保持一致性。这样也方便以后自己程序的调试，至于还有一个作用，在文末可以看到。首先，需要将OpenFOAM的环境说明写入系统.bashrc文件里面： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> <span class="hljs-variable">$HOME</span>/OpenFOAM/OpenFOAM-5.x/etc/bashrc WM_LABEL_SIZE=64 WM_COMPILER_TYPE=system WM_COMPILER=Gcc WM_MPLIB=OPENMPI <br></code></pre></td></tr></table></figure>如果没有报错，说明可以正式编译OpenFOAM了，先进入到Third-party下面：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./Allclean<br>./Allwmake -j4<br><span class="hljs-comment">#如果在集群上，可以用更多核心编译，速度会变快 srun -c64 ./Allwmake -j64</span><br></code></pre></td></tr></table></figure> 如果编译顺利通过，可以编译OpenFOAM: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/OpenFOAM/OpenFOAM-5.x<br>./Allwmake -j4 <span class="hljs-comment">#耗时数小时</span><br><span class="hljs-comment">#同理如果在集群上，可以用更多核心编译，速度会变快 srun -c64 ./Allwmake -j64</span><br></code></pre></td></tr></table></figure>如果没有报错，可以执行一下blockMesh，如果看到出现OpenFOAM的标志，就是安装成功了<imgsrc="https://cdn.nlark.com/yuque/0/2022/png/34567141/1669996035908-f8cdf2e6-bd70-412c-9b9c-6f5b489cc556.png#averageHue=%23fcfcfc&amp;clientId=u417a18bd-49e7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=346&amp;id=u284e3e3e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=346&amp;originWidth=914&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=150713&amp;status=done&amp;style=none&amp;taskId=u75ff3184-01f4-48ed-a678-871b005d833&amp;title=&amp;width=914"alt="image.png" /></p><h1 id="可能遇到的错误">可能遇到的错误</h1><p>目前我遇到的错误，绝大多数情况都是找不到mpi.h，这个是由于openmpi没有配置好。如果按照文中的步骤，最后能看到mpi的环境成功配置应该就没有问题。其次，找不到****.h或者***.c大部分是因为缺少依赖库。例如我一开始在本地虚拟机安装了glibc，libtool库，但是集群中没有，编译一直不过，这个时候建议首先检查依赖库。最后一个，如果Third-party能够成功编译，基本上OpenFOAM也能顺利编译，如果最后实在是编译不过，也找不到原因。可以将本地编译好的Thirdparty打包上传到集群再解压，然后再重新编译，这也是为什么要保持本地虚拟机和集群，操作系统以及安装操作一致性的原因。因为本地虚拟机，权限和上网可控，但是集群都不行，本地的编译出现问题较容易解决。最后看一下我自己的.bashrc文件 <imgsrc="https://cdn.nlark.com/yuque/0/2022/png/34567141/1669996433706-a2323a2a-3a2f-4a42-aac0-f72f887a5100.png#averageHue=%23f6f9e9&amp;clientId=u417a18bd-49e7-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=235&amp;id=u51a4108e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=235&amp;originWidth=480&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=161333&amp;status=done&amp;style=none&amp;taskId=u101bf169-95f6-4f9e-8754-ba3cd834169&amp;title=&amp;width=480"alt="image.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>偏微分方程数值解</tag>
      
      <tag>CFD</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MOOSE多物理场耦合平台入门学习记录（二）- 牛顿法求解非线性方程组</title>
    <link href="/2022/07/05/blog01/"/>
    <url>/2022/07/05/blog01/</url>
    
    <content type="html"><![CDATA[<p>放在首页的话：本人撰写博客最主要的目的是整理自己对研究对象的认识，积累经验，加深理解。自身水平并不高，很多都是靠自学。如果有大佬看出其中的错误或者有新的角度理解，还请留言指点，非常感谢，这对于我水平提高有很大的帮助。</p><h1 id="牛顿法的简介"><a href="#牛顿法的简介" class="headerlink" title="牛顿法的简介"></a>牛顿法的简介</h1><p>NEWTON Solver是MOOSE平台三大求解器之一（NEWTON、JFNK、PJFNK），简要了解牛顿法的基本原理对于理解MOOSE平台的底层机制有一定帮助，也能帮助判断使用NEWTON solver收敛失败的原因。本博文主要参考这篇文章(<a href="https://zhuanlan.zhihu.com/p/139595720)%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E7%AE%80%E6%B4%81%E6%98%8E%E4%BA%86%E7%9A%84%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91(https://www.bilibili.com/video/BV19Q4y1S7dR?spm_id_from=333.337.search-card.all.click&amp;vd_source=b154dc71d458a24aaa3478de44369f37)%E3%80%82">https://zhuanlan.zhihu.com/p/139595720)，以及一个非常简洁明了的教学视频(https://www.bilibili.com/video/BV19Q4y1S7dR?spm_id_from=333.337.search-card.all.click&amp;vd_source=b154dc71d458a24aaa3478de44369f37)。</a></p><h2 id="牛顿法求解非线性方程"><a href="#牛顿法求解非线性方程" class="headerlink" title="牛顿法求解非线性方程"></a>牛顿法求解非线性方程</h2><p>大多数数值分析的教科书都是首先介绍牛顿法求解非线性方程。牛顿法的基本思想来自于泰勒公式，假设现存一个非线性方程$y &#x3D; f(x) &#x3D; b$，首先将方程转化为求根问题，即$F(x) &#x3D; f(x)-b&#x3D;0$。在某一点$x_0$处，进行泰勒展开，可以得到：<br>$$<br>F(x) &#x3D; F(x_0) + F^{‘}(x - x_0) + \frac{F^{‘’}(x_0)}{2}(x - x_0)^2 + O(\Delta x) \tag{1}<br>$$<br>对于线性方程，仅取一阶近似就可以满足要求，可以得到:<br>$$<br>\begin{array}{c}<br>    F(x_0) + F^{‘}(x - x_0) &#x3D; 0 \<br>    x &#x3D; x_0 - \frac{F(x_0)}{F^{‘}(x_0)}<br>\end{array} \tag{2}<br>$$<br>显然此时的$x$并不可能直接就是方程的根，但是可以重复迭代，使得$x$不断逼近方程根，直到满足要求。从图像上看，其过程就是，在一个方程所表达的曲线上选取一个点$x_0$，然后在该点做与曲线的切线，切线与x轴相交的点，其坐标值就是下一步迭代的$x_1$，然后再$x_1$所对应曲线上的点，继续做切线，切线与x轴相交的点$x_3$，反复重复上述过程，直到$x_n$达到预设误差的要求。</p><p>但是，对于需要求解函数的极值问题，取一阶近似就不能满足要求了，需要将其转化为求解其导数为0问题，再使用牛顿法，因此，常见求解非线性方程选取的是二阶近似：<br>$$<br>\begin{array}{c}<br>    F(x) &#x3D; F(x_0) + F^{‘}(x - x_0) + \frac{F^{‘’}(x_0)}{2}(x - x_0)^2 &#x3D; 0<br>\end{array} \tag{3}<br>$$<br>对上式，左右再进行求导可以得到:<br>$$<br>\begin{array}{c}<br>    F^{‘}(x_0) + F^{‘’}(x - x_0) &#x3D; 0 \<br>    x &#x3D; x_0 - \frac{F^{‘}(x_0)}{F^{‘’}(x_0)}<br>\end{array} \tag{4}<br>$$<br>可以看到，牛顿法使用的前提，是曲线导数存在，而在实际使用中，求导数是一个非常难处理的问题，可以使用差分来近似。</p><h2 id="牛顿法求解非线性方程的编程实现"><a href="#牛顿法求解非线性方程的编程实现" class="headerlink" title="牛顿法求解非线性方程的编程实现"></a>牛顿法求解非线性方程的编程实现</h2><p>以方程$x^2 - 2x  -3 &#x3D;0, x&gt;0$为例，其一阶导数和二阶导数分别是$2x-2, 2$，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x*x - <span class="hljs-number">2</span>*x - <span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">firstOD</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#一阶导数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x - <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">secondOD</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#二阶导数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-comment"># 以下为一阶近似牛顿法</span><br>x0 = <span class="hljs-number">0.0</span> <span class="hljs-comment">#初始值</span><br>err_limit = <span class="hljs-number">1e-10</span> <span class="hljs-comment">#误差限</span><br>err_iter = <span class="hljs-number">1.0</span><br>iter_num = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span>(err_iter &gt; err_limit):<br>    xn = x0 - F(x0)/firstOD(x0)<br>    err_iter = <span class="hljs-built_in">abs</span>(xn - x0)<br>    x0 = xn<br>    iter_num = iter_num + <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The iter num for Newton method 1st is &#x27;</span> + <span class="hljs-built_in">str</span>(iter_num))<br></code></pre></td></tr></table></figure><p>示例方程确实太简单了，也可以看到，单纯使用牛顿法编程并不复杂（前提是导数易求解和易计算），还有就是初值的影响非常大，第一个是初值选取不当，容易陷入初值陷阱，计算失败。第二个就是可能迭代不到想要的解，如上面的方程，应该有两个根，如果初值选取小于1.0，则是求解的-1的根，但是实际想要的是$x&gt;0$的解。因为牛顿法单次只能搜寻某个局部区间的解。因此在使用牛顿法前，对方程的几何特性最好要有一定把握。</p><h2 id="牛顿法求解非线性方程组"><a href="#牛顿法求解非线性方程组" class="headerlink" title="牛顿法求解非线性方程组"></a>牛顿法求解非线性方程组</h2><p>如果是方程组，那么解就不是一个单个的数，而是一个解向量$[x_0,x_1,x_2,\cdots,x_n]$，对应方程组为:<br>$$<br>\begin{bmatrix}<br>    f_{1}(x_0,x_1,x_2,\cdots,x_n)  \<br>    f_{2}(x_0,x_1,x_2,\cdots,x_n) \<br>    f_{3}(x_0,x_1,x_2,\cdots,x_n) \<br>      \vdots \<br>    f_{n}(x_0,x_1,x_2,\cdots,x_n)<br>\end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>    0 \<br>    0 \<br>    0 \<br>    \vdots \<br>    0<br>\end{bmatrix} \tag{5}<br>$$<br>对左侧矩阵中的每一项使用多元泰勒展开，与前述过程类似，取一阶梯度，写成迭代格式，可以得到：<br>$$<br>\begin{array}{c}<br>    F(X^{k}) + \nabla F(X^{k})(X^{k+1} - X^{k}) &#x3D; 0 \<br>    (X^{k+1} - X^{k}) &#x3D;  - \nabla F(X^{k})^{-1}F(X^{k})<br>\end{array} \tag{6}<br>$$<br>上式中，$\nabla F(X^{k})$ 就是常见的Jacbobian矩阵，注意，上式中，已经不是简单的乘除法，而是涉及到矩阵求逆运算，并不满足交换律。X也是一个解向量，而不是一个单个数值。Jacbobian矩阵的形式如下：<br>$$<br>\begin{bmatrix}<br>    \frac{\partial f_1}{\partial x_0} &amp; \frac{\partial f_1}{\partial x_1} &amp; \cdots &amp;  \frac{\partial f_1}{\partial x_n} \<br>    \frac{\partial f_2}{\partial x_0} &amp; \frac{\partial f_2}{\partial x_1} &amp; \cdots  &amp; \frac{\partial f_2}{\partial x_n} \<br>    \vdots&amp;\vdots&amp; \ddots &amp; \vdots \<br>    \frac{\partial f_n}{\partial x_0} &amp; \frac{\partial f_n}{\partial x_1} &amp; \cdots  &amp;\frac{\partial f_n}{\partial x_n}<br>\end{bmatrix}<br>$$</p><h2 id="牛顿法求解非线性方程组的编程实现"><a href="#牛顿法求解非线性方程组的编程实现" class="headerlink" title="牛顿法求解非线性方程组的编程实现"></a>牛顿法求解非线性方程组的编程实现</h2><p>以如下方程为示例，其几何意义就是一直线与圆相交的两点。这里仅考虑y&gt;0的解：<br>$$<br>\begin{cases}<br>    x^2 + y^2 &#x3D; 16 \<br>    y -\sqrt{3}x &#x3D; 0<br>\end{cases} \tag{7}<br>$$<br>待求解方程和Jacobian矩阵如下：<br>$$<br>\begin{cases}<br>    x^2 + y^2 -16 &#x3D; 0 \<br>    -\sqrt{3}x + y -4 &#x3D;0<br>\end{cases},<br>\begin{bmatrix}<br>    2x &amp; 2y \<br>    -\sqrt{3} &amp; 1<br>\end{bmatrix}<br>$$<br>代入6式中的迭代表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#以下为牛顿法求解方程组程序</span><br>    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f11</span>(<span class="hljs-params">x</span>): <span class="hljs-comment">#四个偏导数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f12</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f21</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>*sqrt(<span class="hljs-number">3</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f22</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">err_cal</span>(<span class="hljs-params">a,b</span>): <span class="hljs-comment">#计算误差，不同的误差统计方法函数不同，这里采用平方和</span><br>        n = np.size(a,axis=<span class="hljs-number">0</span>)<br>        err_sum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            err_sum = err_sum + (a[i] - b[i])**<span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> sqrt(err_sum)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Jacobian_cal</span>(<span class="hljs-params">x</span>):<br>        n = np.size(x,axis=<span class="hljs-number">0</span>)<br>        tempm = np.zeros([n,n])<br>        tempm[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = f11(x)<br>        tempm[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = f12(x)<br>        tempm[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = f21(x)<br>        tempm[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = f22(x)<br>        <span class="hljs-keyword">return</span> tempm<br>    err_limit = <span class="hljs-number">1e-5</span><br>    err_iter = <span class="hljs-number">1</span><br>    xi = np.zeros([<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])<br>    xi[<span class="hljs-number">0</span>] = <span class="hljs-number">3.0</span><br>    xi[<span class="hljs-number">1</span>] = <span class="hljs-number">2.0</span><br>    JM = np.zeros([<span class="hljs-number">4</span>,<span class="hljs-number">4</span>])<br>    iter_num = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(err_iter &gt; err_limit):<br>        JM = Jacobian_cal(xi)<br>        xi_old = xi.copy()<br>        F = np.zeros([<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])<br>        F[<span class="hljs-number">0</span>] = xi[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> + xi[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span> - <span class="hljs-number">16</span><br>        F[<span class="hljs-number">1</span>] = -sqrt(<span class="hljs-number">3</span>)*xi[<span class="hljs-number">0</span>] + xi[<span class="hljs-number">1</span>]<span class="hljs-comment">#计算F(x^k)</span><br>        <span class="hljs-built_in">print</span>(F)<br>        tempjms = np.linalg.inv(JM) <span class="hljs-comment">#对Jacobian矩阵求逆</span><br>        Rn = -<span class="hljs-number">1</span>*tempjms.dot(F)<br>        xi = xi + Rn <span class="hljs-comment">#计算xi+1，作为下一步迭代初始值</span><br>        err_iter = err_cal(xi_old,xi) <span class="hljs-comment">#计算迭代误差</span><br>        iter_num = iter_num + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(xi)  <span class="hljs-comment">#输出结果</span><br>    <span class="hljs-built_in">print</span>(iter_num)<br></code></pre></td></tr></table></figure><p>在牛顿法中，Jacobian矩阵的性质决定了迭代的结果好坏，有可能会出现如下情况：</p><ol><li>Jacobian矩阵迭代过程中产生奇异，不可以再求逆，迭代就会失败。</li><li>由于求解导数，以及矩阵求逆本身就是很复杂的运算，需要耗费大量计算资源，很容易出现错误，这与方程本身的特性相关。例如，上面方程如果x和y的系数互为相反数，则难以迭代出正确解。</li><li>初值选取不当，造成了后面一系列迭代计算的恶化。</li></ol><p>如果准确求解Jacobian矩阵并且保持迭代过程中矩阵有良好的计算特性是应用牛顿法的大问题。同时也可以看到，牛顿法求解方程组是所有方程同步求解的，并不是类似Picard迭代一样，完成一个场的计算再代入另一个场计算，有利于考虑不同物理场方程之间的高度非线性耦合关系，但是计算要求也更高。</p>]]></content>
    
    
    
    <tags>
      
      <tag>偏微分方程数值解</tag>
      
      <tag>有限差分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
